%%
% @file dg_method.tex
% @brief The note of Discontinuous Galerkin Method.
%
% @author Yufei.Liu, Calm.Liu@outlook.com | Chenyu.Bao, bcynuaa@163.com
% @date 2023-07-18
%
% @version 0.1.0
% @copyright Copyright (c) 2022 - 2024 by SubrosaDG developers. All rights reserved.
% SubrosaDG is free software and is distributed under the MIT license.
%%

\documentclass{develop-note}

\stencilset{
  name = {Discontinuous Galerkin Method},
}

\begin{document}

\section{Governing Equation}

We consider the three-dimensional Navier-Stokes equations written in conservation form
\begin{equation}
  \partial_{t}\mathbf{u}+\nabla\cdot\mathbf{F}_{\mathrm{e}}(\mathbf{u})-\nabla\cdot\mathbf{F}_{\mathrm{v}}(\mathbf{u},\nabla\mathbf{u})=0,
\end{equation}
equipped with suitable initial-boundary conditions. The conservative variables $\mathbf{u}$ and the cartesian components $\mathbf{f}_{\mathrm{e}}(\mathbf{u})$, $\mathbf{g}_{\mathrm{e}}(\mathbf{u})$ and $\mathbf{h}_{\mathrm{e}}(\mathbf{u})$ of the inviscid (Euler) flux function $\mathbf{F}_{\mathrm{e}}(\mathbf{u})$ are given by
\begin{equation}
  \mathbf{u}=\begin{bNiceMatrix}
    \rho\\
    \rho u\\
    \rho v\\
    \rho w\\
    \rho E
  \end{bNiceMatrix},\quad\mathbf{f}_{\mathrm{e}}(\mathbf{u})=\begin{bNiceMatrix}
    \rho u\\
    \rho u u+p\\
    \rho u v\\
    \rho u w\\
    u(\rho E+p)
  \end{bNiceMatrix},\quad\mathbf{g}_{\mathrm{e}}(\mathbf{u})=\begin{bNiceMatrix}
    \rho v\\
    \rho u v\\
    \rho v v+p\\
    \rho v w\\
    v(\rho E+p)
  \end{bNiceMatrix},\quad\mathbf{h}_{\mathrm{e}}(\mathbf{u})=\begin{bNiceMatrix}
    \rho w\\
    \rho u w\\
    \rho v w\\
    \rho w w+p\\
    w(\rho E+p)
  \end{bNiceMatrix},
\end{equation}
where $\rho$ is the fluid density, $u$ and $v$ are the velocity components, $p$ is the pressure, and $E$ is the total internal energy per unit mass. By assuming that the fluid obeys the perfect gas state equation, $p$ can be computed as $p=(\gamma-1)\rho(E-(u^{2}+v^{2})/2)$, where $\gamma$ indicates the ratio between the specific heats of the fluid.

The cartesian components $\mathbf{f}_{\mathrm{v}}(\mathbf{u},\nabla\mathbf{u})$, $\mathbf{g}_{\mathrm{v}}(\mathbf{u},\nabla\mathbf{u})$ and $\mathbf{h}_{\mathrm{v}}(\mathbf{u},\nabla\mathbf{u})$ of the viscous flux function $\mathbf{F}_{\mathrm{v}}(\mathbf{u},\nabla\mathbf{u})$ are given by
\begin{equation}
  \label{eq:3}
  \begin{aligned}
    &\mathbf{f}_{\mathrm{v}}(\mathbf{u},\nabla\mathbf{u})=\begin{bNiceMatrix}
      0\\
      \tau_{xx}\\
      \tau_{xy}\\
      \tau_{xz}\\
      \theta_{x}
    \end{bNiceMatrix},\mathbf{g}_{\mathrm{v}}(\mathbf{u},\nabla\mathbf{u})=\begin{bNiceMatrix}
      0\\
      \tau_{yx}\\
      \tau_{yy}\\
      \tau_{yz}\\
      \theta_{y}
    \end{bNiceMatrix},\mathbf{h}_{\mathrm{v}}(\mathbf{u},\nabla\mathbf{u})=\begin{bNiceMatrix}
      0\\
      \tau_{zx}\\
      \tau_{zy}\\
      \tau_{zz}\\
      \theta_{z}
    \end{bNiceMatrix},\bm{\theta}=\begin{bNiceMatrix}
      u\tau_{xx}+v\tau_{xy}+w\tau_{xz}+\kappa T_{x}\\
      u\tau_{yx}+v\tau_{yy}+w\tau_{yz}+\kappa T_{y}\\
      u\tau_{zx}+v\tau_{zy}+w\tau_{zz}+\kappa T_{z}
    \end{bNiceMatrix},\\
    &\bm{\tau}=\begin{bNiceMatrix}
      2\mu u_{x}+\lambda(u_{x}+v_{y}+w_{z})&\mu(u_{y}+v_{x})&\mu(u_{z}+w_{x})\\
      \mu(u_{y}+v_{x})&2\mu v_{y}+\lambda(u_{x}+v_{y}+w_{z})&\mu(v_{z}+w_{y})\\
      \mu(u_{z}+w_{x})&\mu(v_{z}+w_{y})&2\mu w_{z}+\lambda(u_{x}+v_{y}+w_{z})
    \end{bNiceMatrix}
  \end{aligned}
\end{equation}
where $\mu$ is the dynamic viscosity coefficient, and using the Stokes hypothesis, $\lambda=-(2/3)\mu$. The derivatives of the primitive variables such as $u_{x}$, $u_{y}$, ... can be easily computed by expanding the derivatives of the conservative variables. For example, $(\rho u)_{x}=\rho_{x}u+\rho u_{x}$ , and, therefore, $u_{x}=(1/\rho)((\rho u)_{x}-\rho_{x}u)$.

\section{Spatial Discretization}

Here for the spatial discretization of DG, the reference is from Bassi's paper\cite{bassiHighOrderAccurateDiscontinuous1997a}, which proposed the BR1 format. As a supplement, we also discuss the BR2 format, which you can find in this paper\cite{bassiDiscontinuousGalerkinSolution2005}, but the BR2 format was first proposed in this conference paper\cite{bassiHighOrderAccurate1997}.

By multiplying by a ``test function'' $\mathbf{v}$ and integrating over the domain $\Omega$ we obtain the weighted residual formulation,
\begin{equation}
  \label{eq:4}
  \int_{\Omega}\mathbf{v}\partial_{t}\mathbf{u}\mathrm{d}\Omega+\int_{\Omega}\mathbf{v}\nabla\cdot\mathbf{F}(\mathbf{u},\nabla\mathbf{u})\mathrm{d}\Omega=\sum_{E}\left(\int_{E}\mathbf{v}\partial_{t}\mathbf{u}\mathrm{d}\Omega+\int_{E}\mathbf{v}\nabla\cdot\mathbf{F}(\mathbf{u},\nabla\mathbf{u})\mathrm{d}\Omega\right)=0\quad\forall\mathbf{v},
\end{equation}
where $\mathbf{F}(\mathbf{u},\nabla\mathbf{u})=\mathbf{F}_{\mathrm{e}}(\mathbf{u})-\mathbf{F}_{\mathrm{v}}(\mathbf{u},\nabla\mathbf{u})$, and the integrals over the domain $\Omega$ have been expanded into the sum of integrals over a collection of non-overlapping elements ${E}$, which have been assumed to be triangles and quadrangles. By integrating by parts each elemental contribution of \autoref{eq:4} which contains the divergence of the Navier-Stokes flux function, we obtain the weak formulation
\begin{equation}
  \label{eq:5}
  \sum_{E}\left(\int_{E}\mathbf{v}\partial_{t}\mathbf{u}\mathrm{d}\Omega+\oint_{\partial E}\mathbf{v}\mathbf{F}(\mathbf{u},\nabla\mathbf{u})\cdot\mathbf{n}\mathrm{d}\sigma-\int_{E}\nabla\mathbf{v}\cdot\mathbf{F}(\mathbf{u},\nabla\mathbf{u})\mathrm{d}\Omega\right)=0\quad\forall\mathbf{v},
\end{equation}
where $\partial E$ denotes the boundary of element $E$.

A discrete analog of \autoref{eq:5} is obtained by considering, within each element, only the functions $\mathbf{u}_{h}$ and $\mathbf{v}_{h}$ given by
\begin{equation}
  \mathbf{u}_{h}(\mathbf{x},t)_{h|E}=\sum_{i=1}^{N_{k}}\mathbf{U}_{i}(t)\phi_{i}^{k}(\mathbf{x}),\quad\mathbf{v}_{h}(\mathbf{x})_{h|E}=\sum_{i=1}^{N_{k}}\mathbf{V}_{i}\phi_{i}^{k}(\mathbf{x}),\quad\forall\mathbf{x}\in E,
\end{equation}
where the expansion coefficients $\mathbf{U}_{i}(t)$ and $\mathbf{V}_{i}$ denote the degrees of freedom of the numerical solution and the test function in element $E$, and the $N_{k}$ (shape) functions $\phi_{i}^{k}$ are a base for the polynomial functions $\mathbb{P}^{k}$. Note that there is no global continuity requirement for $\mathbf{u}_{h}$ and $\mathbf{v}_{h}$, which are therefore discontinuous functions across element interfaces. By admitting only the functions $\mathbf{u}_{h|E}$ and $\mathbf{v}_{h|E}$, the summation in \autoref{eq:5} can be reduced to
\begin{equation}
  \label{eq:7}
  \dfrac{\mathrm{d}}{\mathrm{d}t}\int_{E}\mathbf{v}_{h}\mathbf{u}_{h}\mathrm{d}\Omega+\oint_{\partial E}\mathbf{v}_{h}\mathbf{F}(\mathbf{u}_{h},\nabla\mathbf{u}_{h})\cdot\mathbf{n}\mathrm{d}\sigma-\int_{E}\nabla\mathbf{v}_{h}\cdot\mathbf{F}(\mathbf{u}_{h},\nabla\mathbf{u}_{h})\mathrm{d}\Omega=0\quad\forall\mathbf{v}_{h|E}.
\end{equation}
\autoref{eq:7} must be satisfied for any element $E$ and for any function $\mathbf{v}_{h|E}$. However, within each element, the $\mathbf{v}_{h}$ are a linear combination of $N_{k}$ shape functions $\phi_{i}^{k}$, and \autoref{eq:7} is therefore equivalent to the system of $N_{k}$ equations,
\begin{equation}
  \label{eq:8}
  \dfrac{\mathrm{d}}{\mathrm{d}t}\int_{E}\phi_{i}^{k}\mathbf{u}_{h}\mathrm{d}\Omega+\oint_{\partial E}\phi_{i}^{k}\mathbf{F}(\mathbf{u}_{h},\nabla\mathbf{u}_{h})\cdot\mathbf{n}\mathrm{d}\sigma-\int_{E}\nabla\phi_{i}^{k}\cdot\mathbf{F}(\mathbf{u}_{h},\nabla\mathbf{u}_{h})\mathrm{d}\Omega=0\quad 1\leqslant i\leqslant N_{k}.
\end{equation}
% \begin{equation}
%   \label{eq:8}
%   \dfrac{\mathrm{d}}{\mathrm{d}t}\int_{E}\phi_{i}^{k}\mathbf{u}_{h}\mathrm{d}\Omega+\eqnmarkbox[blue]{interface}{\oint_{\partial E}\phi_{i}^{k}\mathbf{F}(\mathbf{u}_{h},\nabla\mathbf{u}_{h})\cdot\mathbf{n}\mathrm{d}\sigma}-\eqnmarkbox[red]{volume}{\int_{E}\nabla\phi_{i}^{k}\cdot\mathbf{F}(\mathbf{u}_{h},\nabla\mathbf{u}_{h})\mathrm{d}\Omega}=0\quad 1\leqslant i\leqslant N_{k}.
% \end{equation}
% \annotate[]{below}{interface}{interface integral}
% \annotate[]{below}{volume}{volume integral}

Notice that, when evaluating the boundary integral of \autoref{eq:8} at an internal interface, the flux terms are not uniquely defined due to the discontinuous function approximation. It is, therefore, necessary to substitute the Navier-Stokes flux function $\mathbf{F}$ with an interface numerical flux function $\mathbf{H}$ which, in general, depends on both interface states and which introduces a coupling between the unknowns of neighboring elements which would be otherwise completely missing. It is possible to show that \autoref{eq:8} with $\mathbf{F}$ replaced by the numerical flux function $\mathbf{H}$ is nothing but the Galerkin method applied to just one element $E$ with weakly prescribed boundary conditions obtained from the neighboring elements of $E$ if $\partial E\cap\partial\Omega =0$ or from the boundary conditions of the Navier-Stokes problem if $\partial E\cap\partial\Omega\neq 0$.

We first restrict our attention to the treatment of interface integrals. The inviscid interface integral terms are constructed with a technique traditionally used in upwind finite volume schemes. The flux function $\mathbf{F}_{\mathrm{e}}(\mathbf{u})\cdot\mathbf{n}$ appearing in the second term of \autoref{eq:7} is in fact replaced by a numerical flux function $\mathbf{h}_{\mathrm{e}}(\mathbf{u}^{-},\mathbf{u}^{+};\mathbf{n})$ depends on the internal interface state $\mathbf{u}^{-}$, on the neighboring element interface state $\mathbf{u}^{+}$, and on the direction of the normal unit vector $\mathbf{n}$. To guarantee the formal accuracy of the scheme, the numerical flux is required to satisfy the consistency relations
\begin{equation}
  \label{eq:9}
  \mathbf{h}_{\mathrm{e}}(\mathbf{u}^{-},\mathbf{u}^{+};\mathbf{n})=\mathbf{F}_{\mathrm{e}}(\mathbf{u})\cdot\mathbf{n},\quad\mathbf{h}_{\mathrm{e}}(\mathbf{u}^{-},\mathbf{u}^{+};\mathbf{n})=-\mathbf{h}_{\mathrm{e}}(\mathbf{u}^{-},\mathbf{u}^{+};-\mathbf{n}),
\end{equation}
Several numerical flux functions satisfy the above criteria such as the Godunov, Lax-Friedrichs, Roe, Engquist-Osher, or HLLE (Harten, Lax, Van Leer, Einfeldt).

The spatial discretization of the viscous term of the Navier-Stokes equations is constructed by resorting to a mixed finite element formulation. The first-order derivatives of the conservative variables appearing in the \autoref{eq:3} lead to second-order derivatives when we evaluate the divergence of the viscous fluxes. However, second-order derivatives cannot be accommodated directly in a weak variational formulation using a discontinuous function space. We therefore regard the gradient of the conservative variables $\mathbf{S}(\mathbf{u})=\nabla\mathbf{u}$ as auxiliary unknowns of the Navier-Stokes equations, which are therefore reformulated as the following coupled system for the unknowns $\mathbf{S}$ and $\mathbf{u}$,
\begin{equation}
  \label{eq:10}
  \begin{aligned}
    &\mathbf{S}-\nabla\mathbf{u}=0\\
    &\partial_{t}\mathbf{u}+\nabla\cdot\mathbf{F}_{\mathrm{e}}(\mathbf{u})-\nabla\cdot\mathbf{F}_{\mathrm{v}}(\mathbf{u},\mathbf{S})=0.
  \end{aligned}
\end{equation}

\autoref{eq:10} can be approximated using a discontinuous finite element formulation in a way similar to that employed for the inviscid part of the equations. The use of an explicit time-stepping scheme greatly simplifies the mixed finite element formulation, since it allows a decoupled solution of \autoref{eq:10}. At each time level $n$, in fact, we first compute a discontinuous approximation of $\mathbf{S}^{n}$ by solving the first equation of the system and then use $\mathbf{u}^{n}$ and $\mathbf{S}^{n}$ to evaluate the inviscid and viscous fluxes of the second equation which is then advanced in time.

The weak formulation of the first equation of \autoref{eq:10} is
\begin{equation}
  \label{eq:11}
  \int_{E}\phi_{i}^{k}\mathbf{S}_{h}\mathrm{d}\Omega-\oint_{\partial E}\phi_{i}^{k}\mathbf{u}_{h}\mathbf{n}\mathrm{d}\sigma+\int_{E}\nabla\phi_{i}^{k}\mathbf{u}_{h}\mathrm{d}\Omega=0\quad 1\leqslant i\leqslant N_{k},
\end{equation}
where, due to the discontinuous function approximation at internal interfaces, the unknown $\mathbf{u}_{h}$ appearing in the boundary integral is not uniquely defined. In analogy with the procedure described for the inviscid part of the equations, it is therefore necessary to introduce a numerical flux function $\mathbf{H}_{\mathrm{s}}(\mathbf{u}^{-},\mathbf{u}^{+};\mathbf{n})$ to replace the term $\mathbf{u}_{h}\mathbf{n}$. Since we are constructing the discrete analog of a diffusive operator, we define the numerical flux function as the average between the two interface states, i.e., as
\begin{equation}
  \label{eq:12}
  \mathbf{H}_{\mathrm{s}}(\mathbf{u}^{-},\mathbf{u}^{+};\mathbf{n})=\dfrac{1}{2}(\mathbf{u}^{-}+\mathbf{u}^{+})\mathbf{n}.
\end{equation}

Here, unlike Bassi, we do not assemble all the mass matrices, but solve \autoref{eq:11} separately on each element $E$. The computed auxiliary variables $\mathbf{S}_{h}$ are then used in the weak form of the second equation of \autoref{eq:10},
\begin{equation}
  \label{eq:13}
  \begin{aligned}
    \dfrac{\mathrm{d}}{\mathrm{d}t}\int_{E}\phi_{i}^{k}\mathbf{u}_{h}\mathrm{d}\Omega &+\oint_{\partial E}\phi_{i}^{k}(\mathbf{F}_{\mathrm{e}}(\mathbf{u}_{h})\cdot\mathbf{n}+\mathbf{F}_{\mathrm{v}}(\mathbf{u}_{h},\mathbf{S}_{h})\cdot\mathbf{n})\mathrm{d}\sigma\\
    &-\int_{E}\nabla\phi_{i}^{k}\cdot(\mathbf{F}_{\mathrm{e}}(\mathbf{u}_{h})+\mathbf{F}_{\mathrm{v}}(\mathbf{u}_{h},\mathbf{S}_{h}))\mathrm{d}\Omega=0\quad 1\leqslant i\leqslant N_{k},
  \end{aligned}
\end{equation}
in which, once again, the boundary integral contains flux terms that are not uniquely defined. It is therefore necessary to replace the term $\mathbf{F}_{\mathrm{v}}(\mathbf{u}_{h},\mathbf{S}_{h})$ with the numerical flux function $\mathbf{h}_{\mathrm{v}}(\mathbf{u}^{-},\mathbf{S}^{-},\mathbf{u}^{+},\mathbf{S}^{+};\mathbf{n})$, defined in a ``centered'' way as
\begin{equation}
  \mathbf{h}_{\mathrm{v}}(\mathbf{u}^{-},\mathbf{S}^{-},\mathbf{u}^{+},\mathbf{S}^{+};\mathbf{n})=\dfrac{1}{2}(\mathbf{F}_{\mathrm{v}}(\mathbf{u}^{-},\mathbf{S}^{-})+\mathbf{F}_{\mathrm{v}}(\mathbf{u}^{+},\mathbf{S}^{+}))\cdot\mathbf{n}
\end{equation}

For there, an important issue in mixed finite element formulations is the choice of the approximation space for the auxiliary variables $\mathbf{S}_{h}$ concerning the original ones, i.e., the conservative variables $\mathbf{u}_{h}$. An inconsistent choice of the two approximation spaces may result in a solution that is polluted by spurious modes. We have not tried to address this issue from a theoretical point of view. In practice, we have used the same type of approximations for both $\mathbf{u}_{h}$ and $\mathbf{S}_{h}$. It is important to point out that, even if both $\mathbf{u}_{h}$ and $\mathbf{S}_{h}$ have been chosen in the same function space (say that of piecewise discontinuous polynomial $\mathbb{P}^{k}$ of order k inside each element), the auxiliary variable $\mathbf{S}_{h}$ can, however, be regarded as the sum of an ``interface contribution'' $\mathbf{S}_{h}^{\mathrm{int}}\in\mathbb{P}^{k}$ plus a ``volume contribution'' $\mathbf{S}_{h}^{\mathrm{vol}}\in\mathbb{P}^{k-1}$. Since $\mathbf{S}_{h}^{\mathrm{int}}$ vanishes when the jump of $\mathbf{u}_{h}$ at the element interfaces is zero, the auxiliary variable $\mathbf{S}_{h}\in\mathbb{P}^{k-1}$ when the solution $\mathbf{u}_{h}\in\mathbb{P}^{k}$ is continuous. In bassi's later papers, he will write $\mathbf{S}_{h}^{\mathrm{vol}}$ as $\nabla\mathbf{u}$ and $\mathbf{S}_{h}^{\mathrm{int}}$ as $\mathbf{R}$, that is to say, there are $\mathbf{S}=\nabla\mathbf{u}+\mathbf{R}$. Here we use the original notation. Next, let's introduce the BR1 format first.

In order to define $\mathbf{S}_{h}^{\mathrm{int}}$ and $\mathbf{S}_{h}^{\mathrm{vol}}$, it is necessary to rewrite the numerical flux function in \autoref{eq:12} as $\mathbf{u}+(\mathbf{u}^{+}-\mathbf{u}^{-})/2$ (here $\mathbf{u}$ is the same as $\mathbf{u}^{-}$). By inserting this expression into the boundary integral of \autoref{eq:11}, we obtain
\begin{equation}
  \label{eq:15}
  \int_{E}\phi_{i}^{k}\mathbf{S}_{h}\mathrm{d}\Omega=\oint_{\partial E}\phi_{i}^{k}\mathbf{u}_{h}\mathbf{n}\mathrm{d}\sigma+\oint_{\partial E}\phi_{i}^{k}\dfrac{1}{2}(\mathbf{u}_{h}^{+}-\mathbf{u}_{h}^{-})\mathbf{n}\mathrm{d}\sigma-\int_{E}\nabla\phi_{i}^{k}\mathbf{u}_{h}\mathrm{d}\Omega.
\end{equation}

Here by replacing $\mathbf{F}$ to $f\mathbf{c}$ for a scalar function $f$ and vector field $\mathbf{c}$ in the \href{https://en.wikipedia.org/wiki/Divergence_theorem}{divergence theorem} with specific forms, we have
\begin{equation}
  \iiint_{V}\mathbf{c}\cdot\nabla f\mathrm{d}V=\oiint_{S}(\mathbf{c}f)\cdot\mathbf{n}\mathrm{d}S-\iiint_{V}f(\nabla\cdot\mathbf{c})\mathrm{d}V.
\end{equation}
The last term on the right vanishes for constant $\mathbf{c}$ or any divergence-free (solenoidal) vector field, e.g. Incompressible flows without sources or sinks such as phase change or chemical reactions etc. In particular, taking
$\mathbf{c}$ to be constant:
\begin{equation}
  \iiint_{V}\nabla f\mathrm{d}V=\oiint_{S}f\mathbf{n}\mathrm{d}S
\end{equation}

Therefore, the first and the last integrals appearing on the right-hand side of \autoref{eq:15} can be (back) integrated by parts to obtain a single volume integral, i.e.,
\begin{equation}
  \oint_{\partial E}\phi_{i}^{k}\mathbf{u}_{h}\mathbf{n}\mathrm{d}\sigma-\int_{E}\nabla\phi_{i}^{k}\mathbf{u}_{h}\mathrm{d}\Omega=\int_{E}\phi_{i}^{k}\nabla\mathbf{u}_{h}\mathrm{d}\Omega.
\end{equation}

\autoref{eq:15} can therefore be rewritten as
\begin{equation}
  \label{eq:18}
  \int_{E}\phi_{i}^{k}\mathbf{S}_{h}\mathrm{d}\Omega=\oint_{\partial E}\phi_{i}^{k}\dfrac{1}{2}(\mathbf{u}_{h}^{+}-\mathbf{u}_{h}^{-})\mathbf{n}\mathrm{d}\sigma+\int_{E}\phi_{i}^{k}\nabla\mathbf{u}_{h}\mathrm{d}\Omega.
\end{equation}

The contributions $\mathbf{S}_{h}^{\mathrm{int}}$ and $\mathbf{S}_{h}^{\mathrm{vol}}$ are given by the boundary and by the volume integrals appearing on the right-hand side of \autoref{eq:18}, i.e.,
\begin{equation}
  \int_{E}\phi_{i}^{k}\mathbf{S}_{h}^{\mathrm{int}}\mathrm{d}\Omega=\oint_{\partial E}\phi_{i}^{k}\dfrac{1}{2}(\mathbf{u}_{h}^{+}-\mathbf{u}_{h}^{-})\mathbf{n}\mathrm{d}\sigma,\quad \int_{E}\phi_{i}^{k}\mathbf{S}_{h}^{\mathrm{vol}}\mathrm{d}\Omega=\int_{E}\phi_{i}^{k}\nabla\mathbf{u}_{h}\mathrm{d}\Omega.
\end{equation}

So for the formulation of BR1, the \autoref{eq:13} can be rewritten as
\begin{equation}
  \label{eq:20}
  \begin{aligned}
    \dfrac{\mathrm{d}}{\mathrm{d}t}\int_{E}\phi_{i}^{k}\mathbf{u}_{h}\mathrm{d}\Omega &+\oint_{\partial E}\phi_{i}^{k}(\mathbf{F}_{\mathrm{e}}(\mathbf{u}_{h})\cdot\mathbf{n}+\mathbf{F}_{\mathrm{v}}(\mathbf{u}_{h},\mathbf{S}_{h}^{\mathrm{int}}+\mathbf{S}_{h}^{\mathrm{vol}})\cdot\mathbf{n})\mathrm{d}\sigma\\
    &-\int_{E}\nabla\phi_{i}^{k}\cdot(\mathbf{F}_{\mathrm{e}}(\mathbf{u}_{h})+\mathbf{F}_{\mathrm{v}}(\mathbf{u}_{h},\mathbf{S}_{h}^{\mathrm{int}}+\mathbf{S}_{h}^{\mathrm{vol}}))\mathrm{d}\Omega=0\quad 1\leqslant i\leqslant N_{k}.
  \end{aligned}
\end{equation}
Unfortunately, this formulation can be shown to be singular in some model problems and displays an unsatisfactory convergence rate for polynomial approximations of odd order.

A cure to this problem, which is BR2 format, has been found by replacing the $\mathbf{S}_{h}^{\mathrm{int}}$ in the contour integral of \autoref{eq:20} with ``face'' contributions redefined as
\begin{equation}
  \int_{E}\phi_{i}^{k}\mathbf{s}_{h|e}^{\mathrm{int}}\mathrm{d}\Omega=\int_{e}\phi_{i}^{k}\dfrac{1}{2}(\mathbf{u}_{h}^{+}-\mathbf{u}_{h}^{-})\mathbf{n}\mathrm{d}\sigma\quad\forall e \in\partial E.
\end{equation}
Notice that the following relation between the functions $\mathbf{S}_{h}^{\mathrm{int}}$ and $\mathbf{s}_{h|e}^{\mathrm{int}}$ holds
\begin{equation}
  \mathbf{S}_{h}^{\mathrm{int}}=\sum_{e\in\partial E}\mathbf{s}_{h|e}^{\mathrm{int}}.
\end{equation}
With this modification, \autoref{eq:20} becomes
\begin{equation}
  \label{eq:23}
  \begin{aligned}
    \dfrac{\mathrm{d}}{\mathrm{d}t}\int_{E}\phi_{i}^{k}\mathbf{u}_{h}\mathrm{d}\Omega &+\oint_{\partial E}\phi_{i}^{k}(\mathbf{F}_{\mathrm{e}}(\mathbf{u}_{h})\cdot\mathbf{n}+\mathbf{F}_{\mathrm{v}}(\mathbf{u}_{h},\eta_{e}\mathbf{s}_{h|e}^{\mathrm{int}}+\mathbf{S}_{h}^{\mathrm{vol}})\cdot\mathbf{n})\mathrm{d}\sigma\\
    &-\int_{E}\nabla\phi_{i}^{k}\cdot(\mathbf{F}_{\mathrm{e}}(\mathbf{u}_{h})+\mathbf{F}_{\mathrm{v}}(\mathbf{u}_{h},\mathbf{S}_{h}^{\mathrm{int}}+\mathbf{S}_{h}^{\mathrm{vol}}))\mathrm{d}\Omega=0\quad 1\leqslant i\leqslant N_{k}.
  \end{aligned}
\end{equation}
In the formula, $\eta_{e}$ is the stability factor, which is usually taken as the number of interfaces of the volume.

\section{Basis Functions}

For the basis function, our implementation is based on \href{https://gmsh.info}{gmsh}, where the isoparametric Lagrange basis functions are used, which is defined as
\begin{equation}
  \phi_{i}^{k}=\prod_{j=1,j\neq i}^{N_{k}}\dfrac{f_{j}(\bm{\xi})}{f_{j}(\bm{\xi}_{i})},\quad 1\leqslant i\leqslant N_{k}.
\end{equation}
The Lagrange basis functions have the following properties
\begin{equation}
  \phi_{i}^{k}(\bm{\xi}_{j})=\delta_{ij},\quad \sum_{i=1}^{N_{k}}\phi_{i}^{k}(\bm{\xi})=1.
\end{equation}
Therefore, we can also construct basis functions by using the undetermined coefficient method for complete polynomials.

For a two-dimensional triangular element, its reference element in gmsh is defined as

\begin{figure}[H]
  \centering
  \includegraphics[width=1.00\textwidth]{figures/tri-reference.pdf}
\end{figure}

From left to right, the reference element of order 1, order 2, and order 3 and the distribution of corresponding Lagrange interpolation points. The shape of the $\phi_{3}^{2}$ and $\phi_{4}^{2}$ of the second-order element are shown here

\begin{figure}[H]
  \centering
  \includegraphics[width=1.00\textwidth]{figures/tri-basis-fun.pdf}
\end{figure}

For a two-dimensional quadrangle element, its reference element in gmsh is defined as

\begin{figure}[H]
  \centering
  \includegraphics[width=1.00\textwidth]{figures/quad-reference.pdf}
\end{figure}

From left to right, the reference element of order 1, order 2, and order 3 and the distribution of corresponding Lagrange interpolation points. The shape of the $\phi_{4}^{2}$ and $\phi_{5}^{2}$ of the second-order element are shown here

\begin{figure}[H]
  \centering
  \includegraphics[width=1.00\textwidth]{figures/quad-basis-fun.pdf}
\end{figure}

For the Lagrange basis functions, it is easy to construct their interpolation functions, and we can convert straight-line elements to curved elements by coordinate transformation. However, this type of element has certain disadvantages, mainly because of the internal nodes that increase with the increase of the interpolation function, thereby increasing the number of degrees of freedom of the element. The addition of these degrees of freedom usually does not improve the accuracy of the element, because the accuracy of the element is usually determined by the power of a complete polynomial.

Next, let's discuss how to compute the derivatives of the basis functions at each element. This is necessary as they appear in the volume integration. Obtaining the derivatives of the basis functions concerning the local coordinates is straightforward since they are polynomials. However, what we need are the derivatives of the basis functions concerning the global coordinates, as we require them for computing the volume integration in the global coordinate system. To achieve this, we need to apply the chain rule, i.e.,
\begin{equation}
  \dfrac{\partial\phi_{i}^{k}}{\partial x_{j}}=\dfrac{\partial\phi_{i}^{k}}{\partial\bm{\xi}}\dfrac{\partial\bm{\xi}}{\partial x_{j}},
\end{equation}
which can be written in matrix form as
\begin{equation}
  \begin{bNiceMatrix}
    \dfrac{\partial\phi_{i}^{k}}{\partial x}\\
    \dfrac{\partial\phi_{i}^{k}}{\partial y}
  \end{bNiceMatrix}=\begin{bNiceMatrix}
    \dfrac{\partial\xi}{\partial x}&\dfrac{\partial\eta}{\partial x}\\
    \dfrac{\partial\xi}{\partial y}&\dfrac{\partial\eta}{\partial y}
  \end{bNiceMatrix}\begin{bNiceMatrix}
    \dfrac{\partial\phi_{i}^{k}}{\partial\xi}\\
    \dfrac{\partial\phi_{i}^{k}}{\partial\eta}
  \end{bNiceMatrix}=[\mathbf{J}]^{-\mathrm{T}}\begin{bNiceMatrix}
    \dfrac{\partial\phi_{i}^{k}}{\partial\xi}\\
    \dfrac{\partial\phi_{i}^{k}}{\partial\eta}
  \end{bNiceMatrix}.
\end{equation}

As the isoparametric element is used here, which means that the interpolation functions for the coordinates transformation of the element's geometry use the same interpolation basis functions and interpolation nodes as those used to describe the displacement modes of the element, we have
\begin{equation}
  \mathbf{x}=\sum_{i=1}^{N_{k}}\phi_{i}^{k}(\bm{\xi})\mathbf{x}_{i}.
\end{equation}
Therefore, we can use this formula to calculate the Jacobi matrix $[\mathbf{J}]$ and its transpose inverse matrix $[\mathbf{J}]^{-\mathrm{T}}$. In the program, we directly use gmsh's API to obtain the derivative values of the basis functions concerning the reference element and the inverse matrix of the Jacobian for each element. Then, we calculate the derivative values of the basis functions concerning the actual element. The \autoref{eq:8} in reference element $E'$ can be written as
\begin{equation}
  \label{eq:30}
  \dfrac{\mathrm{d}}{\mathrm{d}t}\int_{E'}\phi_{i}^{k}\mathbf{u}_{h}|\mathbf{J}|\mathrm{d}\Omega'+\oint_{\partial E'}\phi_{i}^{k}\mathbf{F}(\mathbf{u}_{h},\nabla\mathbf{u}_{h})\cdot\mathbf{n}|\mathbf{J}|\mathrm{d}\sigma'-\int_{E'}[\mathbf{J}]^{-\mathrm{T}}\cdot\nabla\phi_{i}^{k}\cdot\mathbf{F}(\mathbf{u}_{h},\nabla\mathbf{u}_{h})|\mathbf{J}|\mathrm{d}\Omega'=0\quad 1\leqslant i\leqslant N_{k}.
\end{equation}

\section{Numerical Integral}

For the integrals in \autoref{eq:30}, both on the elements and at element edges, numerical integration is typically employed, such as Gauss quadrature. Cockburn's paper\cite{cockburnRungeKuttaLocalProjection1990} provides the order requirements for Gauss quadrature for different integrals in this context. Here's a direct excerpt from the original text: \textit{Assume that the family of triangulations $\mathscr{F}$ is regular and \textbf{B}-uniform. Suppose that $V(K)\supset P^{k}(K)$, $\forall K\in\mathscr{T}_{h}$, $\forall\mathscr{T}_{h}\in\mathscr{F}$, and that the quadrature rule over the edges is exact for polynomials of degree $(2k +1)$, and the quadrature rule over the elements is exact for polynomials of degree $2k$. Then:}
\begin{enumerate}
  \item \textit{The RKDG method is formally uniformly $(k+1)$st-order accurate in time and space if $\Delta t=\mathcal{O}(h)$};
  \item \textit{The approximate solution generated by the RKDG method verifies the maximum principle $(2.8)$ if the CFL-condition $(2.19)$ is verified with $\delta=\mathrm{max}_{i,l}\left|\frac{\beta_{i,l}}{\alpha_{i,l}}\right|$};
  \item \textit{The approximate solution converges to a weak solution of $(1.1)$ if there is a constant $C$ such that $||\bar{u}_{h}||_{BV(\Omega)}\le C$};
\end{enumerate}

The discussion about Gauss quadrature is largely based on Solin\cite{solinHigherOrderFiniteElement2003}, and you can find tables of weights and integration points for different orders of Gaussian quadrature in the book. So let's start from the one-dimensional domain. The quadrature rules of the Gauss type are based on the summation of weighted function values on non-equidistantly distributed integration points. The $n$-point Gauss quadrature rule for the one-dimensional reference domain $K_{a}=(-1,1)$ reads
\begin{equation}
  \int_{-1}^{1}f(\xi)\mathrm{d}\xi\approx\sum_{i=1}^{n}w_{n,i}f(\xi_{n,i}).
\end{equation}
Analogously as for the Chebyshev and Lobatto (Radau) rules, the integration points and weights can be obtained after inserting sufficiently many linearly independent functions with known integrals and resolving the resulting system of nonlinear algebraic equations. Since we have $2n$ unknown parameters at our disposal ($n$ integration points $\xi_{n,i}$ and $n$ weights $w_{n,i}$), the resulting formula will be accurate for all polynomials of order $2n-1$ and lower.

It can be shown that the integration points are roots of the Legendre polynomials $L_{n}(\xi)$. Hence, the complexity of the problem reduces to the level of Newton-Cotes quadrature rules, since with known points the nonlinear system comes over to a system of linear algebraic equations. The analysis leads even further; it is known that the weights $w_{n,i}$ can be expressed as
\begin{equation}
  w_{n,i}=\dfrac{2}{(1-\xi_{n,i}^{2})[L_{n}'(\xi_{n,i})]^{2}}, \quad i=1,\dots,n.
\end{equation}
For two-dimensional Gaussian quadrature in the quadrilateral domain $K_{q}$, let us start with a technique that is easiest to implement - quadrature formulae based on the Cartesian product of two one-dimensional quadrature rules in the axial directions $\xi_{1}$ and $\xi_{2}$. Consider the formula
\begin{equation}
  \int_{K_{a}}f(\xi)\mathrm{d}\xi\approx\sum_{i=1}^{M_{a}}w_{g_{a},i}f(y_{g_{a},i}),
\end{equation}
where $y_{g_{a},i},w_{g_{a},i}$ are Gauss integration points and weights on the one-dimensional reference domain $K_{a}=(-1,1)$ that integrate exactly all polynomials of the order $p$ and lower. It is easy to see that the product formula
\begin{equation}
  \int_{K_{a}}g(\xi_{1},\xi_{2})\mathrm{d}\xi_{1}\mathrm{d}\xi_{2}\approx\sum_{i=1}^{M_{a}}\sum_{j=1}^{M_{a}}w_{g_{a},i}w_{g_{b},j}f(y_{g_{a},i},y_{g_{b},j})
\end{equation}
is of the order $p$ for polynomials of two independent variables $\xi_{1},\xi_{2}$. In addition to its simple implementation, the product formula has one more advantage - it can easily be generalized to polynomials with different orders of approximation in the axial directions $\xi_{1},\xi_{2}$. Such polynomials may appear naturally as a consequence of $p$-anisotropic refinements of quadrilateral elements, that may occur, e.g., within boundary and internal layers. However, the Gaussian quadrature formulas obtained in this way do not always use the minimum number of points. It is possible to achieve a more efficient Gaussian quadrature formula by eliminating some symmetric points while maintaining the original polynomial degree. We won't go into the specific details of this approach here, as it is not the one we have adopted.

However, for triangular elements, the situation is more complicated. The fundamental equation for the construction of the integration points and weights for the reference triangle $K_{t}$ reads
\begin{equation}
  \int_{-1}^{1}\int_{-1}^{1-\xi_{1}}f(\xi_{1},\xi_{2})\mathrm{d}\xi_{2}\mathrm{d}\xi_{1}\approx\sum_{i=1}^{m}w_{k}f(\xi_{1,k},\xi_{2,k}),
\end{equation}
where $m$ denotes the number of integration points. Each point is characterized by three unknowns: $\omega_{k},\xi_{1,k}$ and $\xi_{2,k}$. If we want to solve for these three unknowns, we will need to solve a nonlinear system of algebraic equations. It is practically infeasible to calculate the integration points and weights for higher values of $p$ by standard methods or mathematical software. Lyness\cite{lynessModerateDegreeSymmetric1975} proposed a sophisticated algorithm based on determining the points and weights within an equilateral triangle in polar coordinates, taking advantage of its multiple symmetries. The algorithm provides the minimum number of Gaussian points for any polynomial order $p$ and strongly reduces the size of the nonlinear system. Dunavant\cite{dunavantHighDegreeEfficient1985} extended the algorithm and calculated the points and weights up to the order $p=20$ (some weights being negative and some points lying outside the triangle). The position of integration points and values of the weights corresponding to other triangles can be obtained by a simple affine transformation.

The fact that some of the weights are negative means that the stability of the quadrature will tend to decrease when integrating oscillatory functions whose polynomial behavior exceeds the order of accuracy of the quadrature formulae. In this case, the schemes still can be used, but one has to combine them with spatial refinements of the reference element. If oscillations (or other excessive nonlinearities) in the integrated functions are expected, an application of adaptive formulae that compare results from several refinement levels may be a good idea.

\section{Convective Flux}

We mentioned some methods for calculating convective numerical fluxes at \autoref{eq:9}, and here we will introduce these methods in some detail. Note that what our convective numerical flux needs to replace here is $\mathbf{F}_{\mathrm{e}}(\mathbf{u})\cdot\mathbf{n}$, which means that the flux we calculate is on the normal vector $\mathbf{n}$, which will cause a relatively large change compared to the one-dimensional form for some schemes. Here we focus on how to calculate these formats, and we will not introduce too much about the properties and derivation of these schemes.

Here we first define some symbols that we will use next. The first is the value on the left and right sides of the conserved variable $\mathbf{u}$. $\mathbf{u}^{-}$ represents the value on the left side of the interface, and $\mathbf{u}^{+}$ represents the value on the right side of the interface. $V=u n_{x}+v n_{y}+w n_{z}$ represents the velocity along the interface normal vector.
\begin{equation}
  \mathbf{F}_{\mathrm{e},n}=\mathbf{F}_{\mathrm{e}}\cdot\mathbf{n}=\mathbf{f}_{\mathrm{e}}n_{x}+\mathbf{g}_{\mathrm{e}}n_{y}+\mathbf{h}_{\mathrm{e}}n_{z}=\begin{bNiceMatrix}
    \rho(u n_{x}+v n_{y}+w n_{z})\\
    \rho u(u n_{x}+v n_{y}+w n_{z})+p n_{x}\\
    \rho v(u n_{x}+v n_{y}+w n_{z})+p n_{y}\\
    \rho w(u n_{x}+v n_{y}+w n_{z})+p n_{z}\\
    (u n_{x}+v n_{y}+w n_{z})(\rho E+p)
  \end{bNiceMatrix}=\begin{bNiceMatrix}
    \rho V\\
    \rho u V+p n_{x}\\
    \rho v V+p n_{y}\\
    \rho w V+p n_{z}\\
    V(\rho E+p)
  \end{bNiceMatrix}
\end{equation}

\subsection*{Lax-Friedrichs Scheme}

The Lax-Friedrichs scheme is the simplest, and it is also the most stable scheme. The Lax-Friedrichs scheme can be evaluated by the following formula
\begin{equation}
  \mathbf{h}_{\mathrm{e}}(\mathbf{u}^{-},\mathbf{u}^{+};\mathbf{n})=\dfrac{1}{2}(\mathbf{F}_{\mathrm{e},n}(\mathbf{u}^{-})+\mathbf{F}_{\mathrm{e},n}(\mathbf{u}^{+}))-\dfrac{1}{2}\alpha(\mathbf{u}^{+}-\mathbf{u}^{-}),
\end{equation}
where $\alpha$ is the maximum eigenvalue of the Jacobian matrix $\mathbf{A}_{\mathrm{e},n}(\mathbf{u})=\partial\mathbf{F}_{\mathrm{e},n}/\partial\mathbf{u}$ of the convective flux along the normal vector direction. The eigenvalues are
\begin{equation}
  \lambda_{1}=V-c,\quad\lambda_{2}=V,\quad\lambda_{3}=V,\quad\lambda_{4}=V,\quad\lambda_{5}=V+c.
\end{equation}

\subsection*{HLLC Scheme}

The derivation of the HLLC scheme is based on the book of Toro\cite{toroRiemannSolversNumerical2009a} and the paper of Batten et al.\cite{battenChoiceWavespeedsHLLC1997}. To determine completely the numerical fluxes in the HLLC scheme, we need to provide an algorithm for computing the wave speeds $S^{-}$, $S^{+}$ and $S^{*}$. The $S^{-}$ and $S^{+}$ are the speeds of the left and right waves, respectively, and $S^{*}$ is the speed of the contact wave. Here we use the pressure-based wave speed estimates proposed by Toro to calculate the wave speeds, whereby one first finds an estimate for the pressure $p^{*}$. For the estimate of the pressure, we use the ideal gases simplified PVRS approximate Riemann solver to calculate it.

Step one is to calculate the pressure $p^{*}$, which is given by
\begin{equation}
  p^{*}=\max(0, p_{\mathrm{pvrs}}),\quad p_{\mathrm{pvrs}}=\dfrac{1}{2}(p^{-}+p^{+})-\dfrac{1}{2}(V^{+}-V^{-})\bar{\rho}\bar{c},\quad\bar{\rho}=\dfrac{1}{2}(\rho^{-}+\rho^{+}),\quad\bar{c}=\dfrac{1}{2}(c^{-}+c^{+}).
\end{equation}

Step two is to calculate the wave speeds $S^{-}$, $S^{+}$ and $S^{*}$. The $S^{-}$ and $S^{+}$ are the speeds of the left and right waves, respectively, which are given by
\begin{equation}
  S^{-}=V^{-}-c^{-}q^{-},\quad S^{+}=V^{+}+c^{+}q^{+},\quad q^{\pm}=
  \begin{cases}
    1&\text{if }p^{*}\leqslant p^{\pm},\\
    \sqrt{1+\dfrac{\gamma+1}{2\gamma}\left(\dfrac{p^{*}}{p^{\pm}}-1\right)}&\text{if }p^{*}>p^{\pm}.
  \end{cases}
\end{equation}
Then the $S^{*}$ is the speed of the contact wave, which is given by
\begin{equation}
  S^{*}=\dfrac{p^{+}-p^{-}+\rho^{-}V^{-}(S^{-}-V^{-})-\rho^{+}V^{+}(S^{+}-V^{+})}{\rho^{-}(S^{-}-V^{-})-\rho^{+}(S^{+}-V^{+})}.
\end{equation}

Step three is to calculate the HLLC numerical fluxes. The HLLC numerical fluxes are given by
\begin{equation}
  \mathbf{h}_{\mathrm{e}}(\mathbf{u}^{-},\mathbf{u}^{+};\mathbf{n})=
  \begin{cases}
    \mathbf{F}_{\mathrm{e},n}(\mathbf{u}^{-})&\text{if }0\leqslant S^{-},\\
    \mathbf{F}_{\mathrm{e},n}(\mathbf{u}^{-})+S^{-}(\mathbf{u}^{*,-}-\mathbf{u}^{-})&\text{if }S^{-}\leqslant 0\leqslant S^{*},\\
    \mathbf{F}_{\mathrm{e},n}(\mathbf{u}^{+})+S^{+}(\mathbf{u}^{*,+}-\mathbf{u}^{+})&\text{if }S^{*}\leqslant 0\leqslant S^{+},\\
    \mathbf{F}_{\mathrm{e},n}(\mathbf{u}^{+})&\text{if }0\geqslant S^{+},
  \end{cases}
\end{equation}
where $\mathbf{u}^{*,-}$ and $\mathbf{u}^{*,+}$ are the intermediate states on the left and right sides of the interface, respectively, which are given by
\begin{equation}
  \mathbf{u}^{*,\pm}=\begin{bNiceMatrix}
    \rho^{\pm}\dfrac{S^{\pm}-V^{\pm}}{S^{\pm}-S^{*}}\\
    \dfrac{\rho^{\pm}V^{\pm}(S^{\pm}-V^{\pm})+(p^{*}-p^{\pm})n_{x}}{S^{\pm}-S^{*}}\\
    \dfrac{\rho^{\pm}V^{\pm}(S^{\pm}-V^{\pm})+(p^{*}-p^{\pm})n_{y}}{S^{\pm}-S^{*}}\\
    \dfrac{\rho^{\pm}V^{\pm}(S^{\pm}-V^{\pm})+(p^{*}-p^{\pm})n_{z}}{S^{\pm}-S^{*}}\\
    \dfrac{\rho^{\pm}E^{\pm}(S^{\pm}-V^{\pm})-p^{\pm}V^{\pm}+p^{*}S^{*}}{S^{\pm}-S^{*}}
  \end{bNiceMatrix}.
\end{equation}

\subsection*{Roe Scheme}

Most of the derivation of the Roe scheme here comes from the books of Blazek\cite{blazekComputationalFluidDynamics2015} and Toro\cite{toroRiemannSolversNumerical2009a}, and some of them are derived by myself. The Roe scheme can be evaluated by the following formula
\begin{equation}
  \begin{aligned}
    \mathbf{h}_{\mathrm{e}}(\mathbf{u}^{-},\mathbf{u}^{+};\mathbf{n})&=\dfrac{1}{2}(\mathbf{F}_{\mathrm{e},n}(\mathbf{u}^{-})+\mathbf{F}_{\mathrm{e},n}(\mathbf{u}^{+}))-\dfrac{1}{2}\tilde{\mathbf{A}}_{\mathrm{e}}(\mathbf{u}^{+}-\mathbf{u}^{-})\\
    &=\dfrac{1}{2}(\mathbf{F}_{\mathrm{e},n}(\mathbf{u}^{-})+\mathbf{F}_{\mathrm{e},n}(\mathbf{u}^{+}))-\dfrac{1}{2}\sum_{i=1}^{m}\tilde{\alpha}_{i}|\tilde{\lambda}_{i}|\tilde{\mathbf{K}}_{i}.
  \end{aligned}
\end{equation}

The $\tilde{\mathbf{u}}$ is used to represent the Roe variable, and $\Delta{\mathbf{u}}$ is used to represent the difference on the element interface, that is $\mathbf{u}^{+}-\mathbf{u}^{-}$. Next we calculate the Jacobian matrix $\mathbf{A}_{\mathrm{e},n}(\mathbf{u})=\partial\mathbf{F}_{\mathrm{e},n}/\partial\mathbf{u}$ of the convective flux along the normal vector direction. The form of $\mathbf{A}_{\mathrm{e},n}$ is complicated, so it is not given here. The eigenvalues are
\begin{equation}
  \lambda_{1}=V-c,\quad\lambda_{2}=V,\quad\lambda_{3}=V,\quad\lambda_{4}=V,\quad\lambda_{5}=V+c,
\end{equation}
where $c$ is the speed of sound. The corresponding right eigenvectors are
\begin{equation}
  \begin{aligned}
    &\mathbf{K}_{1}=\begin{bNiceMatrix}
      1\\
      u-c n_{x}\\
      v-c n_{y}\\
      w-c n_{z}\\
      H-c V
    \end{bNiceMatrix},\quad\mathbf{K}_{2}=\begin{bNiceMatrix}
      1\\
      u\\
      v\\
      w\\
      (u^{2}+v^{2}+w^{2})/2
    \end{bNiceMatrix},\quad\mathbf{K}_{3}=\begin{bNiceMatrix}
      0\\
      -n_{y}/n_{x}\\
      1\\
      0\\
      v-n_{y}u/n_{x}\\
    \end{bNiceMatrix},\\
    &\mathbf{K}_{4}=\begin{bNiceMatrix}
      0\\
      -n_{z}/n_{x}\\
      0\\
      1\\
      w-n_{z}u/n_{x}\\
    \end{bNiceMatrix},\quad\mathbf{K}_{5}=\begin{bNiceMatrix}
      1\\
      u+c n_{x}\\
      v+c n_{y}\\
      w+c n_{z}\\
      H+c V
    \end{bNiceMatrix}.
  \end{aligned}
\end{equation}

Since the form of $\mathbf{A}_{\mathrm{e},n}$ here is complex, calculating the eigenvector will require a little skill. First, we use the chain rule to calculate the derivative of $\mathbf{A}_{\mathrm{e},n}$ for $\mathbf{u}$. The original variable can be expressed as
\begin{equation}
  \mathbf{q}=\begin{bNiceMatrix}
    \rho\\
    u\\
    v\\
    w\\
    p\\
  \end{bNiceMatrix}.
\end{equation}
We cannot directly differentiate the conserved variable $\mathbf{u}$, so the chain rule is used here
\begin{equation}
  \mathbf{A}_{\mathrm{e},n}=\dfrac{\partial\mathbf{F}_{\mathrm{e},n}}{\partial\mathbf{u}}=\dfrac{\partial\mathbf{F}_{\mathrm{e},n}}{\partial\mathbf{q}}\dfrac{\partial\mathbf{q}}{\partial\mathbf{u}}=\dfrac{\partial\mathbf{F}_{\mathrm{e},n}}{\partial\mathbf{q}}\left(\dfrac{\partial\mathbf{u}}{\partial\mathbf{q}}\right)^{-1}.
\end{equation}
Let's consider $\mathbf{M}=\partial\mathbf{u}/\partial\mathbf{q}$. We then proceed to apply a similarity transformation to $\mathbf{A}_{\mathrm{e},n}$, resulting in
\begin{equation}
  \mathbf{a}_{\mathrm{e},n}=\mathbf{M}^{-1}\mathbf{A}_{\mathrm{e},n}\mathbf{M}.
\end{equation}
The form of $\mathbf{a}_{\mathrm{e},n}$ relative to $\mathbf{A}_{\mathrm{e},n}$ will be much simpler. And since we are performing a similarity transformation, the eigenvalues of these two matrices are the same. Let $\mathbf{k}$ be the right eigenvector of $\mathbf{a}_{\mathrm{e},n}$, then we have:
\begin{equation}
  \mathbf{k}^{-1}\mathbf{a}_{\mathrm{e},n}\mathbf{k}=\mathbf{\Lambda}\Rightarrow(\mathbf{M}\mathbf{k})^{-1}\mathbf{A}_{\mathrm{e},n}\mathbf{M}\mathbf{k}=\mathbf{\Lambda}\Rightarrow\mathbf{K}=\mathbf{M k}.
\end{equation}
Note that the eigenvectors obtained in this way may differ from those provided earlier, as eigenvectors can be scaled by a non-zero factor without affecting the final result. While this scaling doesn't impact the outcome, the coefficients in subsequent steps may vary.

Bring the Roe variable into the right eigenvector to get $\tilde{\mathbf{K}}_{i}$. The Roe variable is defined as
\begin{equation}
  \begin{aligned}
    &\tilde{\rho}=\sqrt{\rho^{-}\rho^{+}},\quad\tilde{u}=\dfrac{\sqrt{\rho^{-}}u^{-}+\sqrt{\rho^{+}}u^{+}}{\sqrt{\rho^{-}}+\sqrt{\rho^{+}}},\quad\tilde{v}=\dfrac{\sqrt{\rho^{-}}v^{-}+\sqrt{\rho^{+}}v^{+}}{\sqrt{\rho^{-}}+\sqrt{\rho^{+}}},\quad\tilde{w}=\dfrac{\sqrt{\rho^{-}}w^{-}+\sqrt{\rho^{+}}w^{+}}{\sqrt{\rho^{-}}+\sqrt{\rho^{+}}},\\
    &\tilde{H}=\tilde{E}+\dfrac{\tilde{p}}{\tilde{\rho}}=\dfrac{\sqrt{\rho^{-}}H^{-}+\sqrt{\rho^{+}}H^{+}}{\sqrt{\rho^{-}}+\sqrt{\rho^{+}}},\quad\tilde{V}=\tilde{u}n_{x}+\tilde{v}n_{y}+\tilde{w}n_{z}
  \end{aligned}
\end{equation}
Then we give the wave strengths $\tilde{\alpha}_{i}$ of these right eigenvectors, which can be calculated through this system of equations
\begin{equation}
  \sum_{i=1}^{m}\tilde{\alpha}_{i}\tilde{\mathbf{K}}_{i}=\Delta\mathbf{u}.
\end{equation}
When written in full these equations read
\begin{equation}
  \begin{aligned}
    &\tilde{\alpha}_{1}+\tilde{\alpha}_{2}+\tilde{\alpha}_{5}=\Delta\rho,\\
    &\tilde{\alpha}_{1}(\tilde{u}-\tilde{c}n_{x})+\tilde{\alpha}_{2}\tilde{u}-\tilde{\alpha}_{3}n_{y}/n_{x}-\tilde{\alpha}_{4}n_{z}/n_{x}+\tilde{\alpha}_{5}(\tilde{u}+\tilde{c}n_{x})=\Delta(\rho u),\\
    &\tilde{\alpha}_{1}(\tilde{v}-\tilde{c}n_{y})+\tilde{\alpha}_{2}\tilde{v}+\tilde{\alpha}_{3}+\tilde{\alpha}_{5}(\tilde{v}+\tilde{c}n_{y})=\Delta(\rho v),\\
    &\tilde{\alpha}_{1}(\tilde{w}-\tilde{c}n_{z})+\tilde{\alpha}_{2}\tilde{w}+\tilde{\alpha}_{4}+\tilde{\alpha}_{5}(\tilde{w}+\tilde{c}n_{z})=\Delta(\rho w),\\
    &\tilde{\alpha}_{1}(\tilde{H}-\tilde{c}\tilde{V})+\tilde{\alpha}_{2}(\tilde{u}^{2}+\tilde{v}^{2}+\tilde{w}^{2})/2+\tilde{\alpha}_{3}(\tilde{v}-\tilde{c}n_{y})+\tilde{\alpha}_{4}(\tilde{w}-\tilde{c}n_{z})+\tilde{\alpha}_{5}(\tilde{H}+\tilde{c}\tilde{V})=\Delta(\rho E).
  \end{aligned}
\end{equation}
The wave strength $\tilde{\alpha}_{i}$ can be calculated by solving this system of equations. Here we neglecting the $\mathcal{O}(\Delta^{2})$, so $\Delta(\rho u)=u\Delta\rho+\rho\Delta u$. Then we can get the following results
\begin{equation}
  \begin{aligned}
    &\tilde{\alpha}_{1}=(\Delta p-\tilde{\rho}\tilde{c}\Delta V)/(2\tilde{c}^{2}),\\
    &\tilde{\alpha}_{2}=\Delta\rho-\Delta p/\tilde{c}^{2},\\
    &\tilde{\alpha}_{3}=\tilde{\rho}(\Delta v-\Delta V n_{y}),\\
    &\tilde{\alpha}_{4}=\tilde{\rho}(\Delta w-\Delta V n_{z}),\\
    &\tilde{\alpha}_{5}=(\Delta p+\tilde{\rho}\tilde{c}\Delta V)/(2\tilde{c}^{2}).
  \end{aligned}
\end{equation}
If you need, the formula $\tilde{\alpha}_{3}\tilde{\mathbf{K}}_{3}+\tilde{\alpha}_{4}\tilde{\mathbf{K}}_{4}$here can be partially simplified
\begin{equation}
  \begin{aligned}
    \tilde{\alpha}_{3}\tilde{\mathbf{K}}_{3}+\tilde{\alpha}_{4}\tilde{\mathbf{K}}_{4}&=\tilde{\rho}(\Delta v-\Delta V n_{y})\begin{bNiceMatrix}
      0\\
      -n_{y}/n_{x}\\
      1\\
      0\\
      v-n_{y}u/n_{x}\\
    \end{bNiceMatrix}+\tilde{\rho}(\Delta w-\Delta V n_{z})\begin{bNiceMatrix}
      0\\
      -n_{z}/n_{x}\\
      0\\
      1\\
      w-n_{z}u/n_{x}\\
    \end{bNiceMatrix}\\
    &=\tilde{\rho}\begin{bNiceMatrix}
      0\\
      \Delta u - \Delta V n_{x}\\
      \Delta v - \Delta V n_{y}\\
      \Delta w - \Delta V n_{z}\\
      \tilde{u}\Delta u+\tilde{v}\Delta v+\tilde{w}\Delta w-\tilde{V}\Delta V\\
    \end{bNiceMatrix}
  \end{aligned}
\end{equation}
Before applying the scheme as described to practical problems, a modification using Harten's entropy correction to handle sonic flow correctly is required.
\begin{equation}
  |\tilde{\lambda}_{c}|=|\tilde{V}\pm\tilde{c}|=\begin{dcases*}
    |\tilde{\lambda}_{c}|, & if $|\tilde{\lambda}_{c}|>\delta$\\
    (\tilde{\lambda}_{c}^{2}+\delta^{2})/(2\delta), & if $|\tilde{\lambda}_{c}|\leqslant\delta$
  \end{dcases*},
\end{equation}
Where $\delta$ is a small value, which can be conveniently set equal to some fraction (e.g., $1/10$ Or $1/20$) of the local speed of sound.

\section{Diffusive Flux}


\section{Time Integration}


\section{Boundary Condition}


\section{Post Processing}


\section{Variable Storage}

% TODO: DOP

For scientific computing, the storage of variables can generally be divided into two paradigms. For instance, when dealing with all the information on a particular element, you can either store each piece of information separately in an array or wrap these pieces of information into a structure and store them as an array. These two approaches are respectively known as Structure of Arrays (SOA) and Array of Structures (AOS).

The SOA approach is more efficient because it can leverage CPU vectorized instructions. For example, during optimization, it can easily trigger the compiler's SIMD optimization. The AOS approach, on the other hand, cannot do this. However, the SOA approach also has a drawback in that its memory access is non-contiguous, leading to cache misses and reduced efficiency. This problem becomes more severe for unstructured grids because, in a loop, you may access many data belonging to the same element. If these data are stored using SOA, cache misses can occur when accessing them, reducing efficiency.

Therefore, in most of our program implementations, we organize data for the same element into a structure and then store these structures in an array. This ensures that when accessing data for the same element, the data is contiguous, avoiding cache misses. Within this structure, we use the SOA approach to store data, ensuring that when computing data belonging to the same element, we can trigger compiler SIMD optimizations. Of course, you can think of this method as a combination of SOA and AOS, that is, \href{https://en.wikipedia.org/wiki/AoS_and_SoA}{AOSOA}, but we prefer to think of it as AOS. Because in our program, we only store data in structures instead of treating the structures as a whole.

Moreover, all storage for the variables required for computations is done using Eigen Matrix, Vector and Array as the underlying storage. This allows us to directly utilize Eigen API for calculations without the need to implement matrix and vector operations ourselves, significantly reducing our workload. Eigen API is highly optimized, so there is also minimal loss in efficiency.

Considering that the storage order of matrices in Eigen is column-major, the order in memory is column 0, column 1... and is stored like this. Therefore, the system of equations is transposed here, that is, changing i in \autoref{eq:30} from row order to column order. In this way, when we process data within a single unit, each column represents the weighted residuals resulting from the multiplication of a certain basis function with the equation. This can help improve cache hit rates in certain loops.

Regarding how the data is encapsulated, let's set that aside for now and first take a look at how various variables in the equations are stored in one element.

We start with the Integral class, first, the local coordinates of the integration point, which is the \texttt{integral\_point} variable in the program, is a variable of type \texttt{Eigen::Matrix}. The dimension of this matrix is \texttt{getDim<ElemT>()} $\times$ \texttt{getElemIntegralNum<ElemT>(P)}, where \texttt{getDim<ElemT>()} is the dimension of the reference element, and \texttt{getElem} \texttt{IntegralNum<ElemT>(P)} is the number of integration points of the element. Each column of this matrix stores the local coordinates of an integration point. For example, for a two-dimensional element, the variable is
\begin{equation}
  \begin{bNiceMatrix}
    \xi_{1}^{0}&\xi_{1}^{1}&\Cdots&\xi_{1}^{n}\\
    \xi_{2}^{0}&\xi_{2}^{1}&\Cdots&\xi_{2}^{n}
  \end{bNiceMatrix}_{\texttt{Dim}\times\texttt{ElemIntegralNum}.}
\end{equation}

% The weight of the integration point, which is the \texttt{weight} variable in the program, is a variable of type \texttt{Eigen::Vector}. The dimension of this vector is \texttt{getElemIntegralNum<ElemT>(P)} $\times 1$, where \texttt{getElemIntegralNum<ElemT>(P)} is the number of integration points of the element. The column of this vector stores the weight of an integration point. For example, for an element, the variable is
% \begin{equation}
%   \begin{bNiceMatrix}
%     w^{0} \\
%     w^{1} \\
%     \Vdots\\
%     w^{n}
%   \end{bNiceMatrix}_{\texttt{ElemIntegralNum}\times 1.}
% \end{equation}

The value of the basis function at each integration point, which is the \texttt{basis\_fun} variable in the program, is a variable of type \texttt{Eigen::Matrix}. The dimension of this matrix is \texttt{getElemIntegralNum<ElemT>(P)} $\times$ \texttt{calBasisFunNum<ElemT>(P)}, where \texttt{getElemIntegralNum<ElemT>(P)} is the number of integration points of the element, and \texttt{calBasisFunNum<ElemT>(P)} is the number of basis functions of the element. Each column of this matrix stores the value of a basis function at an integration point. For example, for an element, the variable is
\begin{equation}
  \begin{bNiceMatrix}
    \phi_{1}^{0}&\phi_{1}^{1}&\Cdots&\phi_{1}^{n}\\
    \phi_{2}^{0}&\phi_{2}^{1}&\Cdots&\phi_{2}^{n}\\
    \Vdots      &\Vdots      &      &\Vdots      \\
    \phi_{m}^{0}&\phi_{m}^{1}&\Cdots&\phi_{m}^{n}
  \end{bNiceMatrix}_{\texttt{ElemIntegralNum}\times\texttt{BasisFunNum}.}
\end{equation}

The value of the gradient of the basis function at each integration point, which is the \texttt{basis\_fun\_grad} variable in the program, is a variable of type \texttt{Eigen::Matrix}. The dimension of this matrix is (\texttt{getElemIntegralNum<ElemT>(P)} $\times$ \texttt{getDim<ElemT>()}) $\times$ \texttt{calBasisFunNum<ElemT>(P)}, where \texttt{getElemIntegralNum<ElemT>(P)} is the number of integration points of the element,  \texttt{getDim<ElemT>()} is the dimension of the reference element, and \texttt{calBasisFunNum<ElemT>(P)} is the number of basis functions of the element. Each column of this matrix stores the value of the gradient of a basis function at an integration point. For example, for a two-dimensional element, the variable is
\begin{equation}
  \begin{bNiceMatrix}
    \dfrac{\partial\phi_{1}^{0}}{\partial\xi_{1}}&\dfrac{\partial\phi_{1}^{1}}{\partial\xi_{1}}&\Cdots&\dfrac{\partial\phi_{1}^{n}}{\partial\xi_{1}}\\
    \dfrac{\partial\phi_{1}^{0}}{\partial\xi_{2}}&\dfrac{\partial\phi_{1}^{1}}{\partial\xi_{2}}&\Cdots&\dfrac{\partial\phi_{1}^{n}}{\partial\xi_{2}}\\
    \dfrac{\partial\phi_{2}^{0}}{\partial\xi_{1}}&\dfrac{\partial\phi_{2}^{1}}{\partial\xi_{1}}&\Cdots&\dfrac{\partial\phi_{2}^{n}}{\partial\xi_{1}}\\
    \dfrac{\partial\phi_{2}^{0}}{\partial\xi_{2}}&\dfrac{\partial\phi_{2}^{1}}{\partial\xi_{2}}&\Cdots&\dfrac{\partial\phi_{2}^{n}}{\partial\xi_{2}}\\
    \Vdots                                       &\Vdots                                       &      &\Vdots                                       \\
    \dfrac{\partial\phi_{m}^{0}}{\partial\xi_{1}}&\dfrac{\partial\phi_{m}^{1}}{\partial\xi_{1}}&\Cdots&\dfrac{\partial\phi_{m}^{n}}{\partial\xi_{1}}\\
    \dfrac{\partial\phi_{m}^{0}}{\partial\xi_{2}}&\dfrac{\partial\phi_{m}^{1}}{\partial\xi_{2}}&\Cdots&\dfrac{\partial\phi_{m}^{n}}{\partial\xi_{2}}
  \end{bNiceMatrix}_{(\texttt{ElemIntegralNum}\times\texttt{Dim})\times\texttt{BasisFunNum}}.
\end{equation}

Next let's look at Mesh class, first the

The basis function coefficients, which is the \texttt{basis\_fun\_coeff} variable in the program, is a variable of type \texttt{Eigen::Array} of \texttt{Eigen::Matrix}. The dimension of the array is $2\times 1$, which means it contains two matrices. The first one is to record the data of the initial step in the explicit time integration, and the second one is to record the data of the current step. The dimension of each matrix is \texttt{getConservedVarNum<EquModelT>(Dim)} $\times$ \texttt{calBasisFunNum<ElemT>(P)}, where \texttt{getConservedVarNum<EquModelT>(Dim)} is the number of conservative variables of the equation, and \texttt{calBasisFunNum} \texttt{<ElemT>(P)} is the number of basis functions of the element. Each column of this matrix stores the basis function coefficients of a conservative variable on an element. For Navier-Stokes equations, the variable is
\begin{equation}
  \begin{bNiceMatrix}
    a_{\rho}^{0}  &a_{\rho}^{1}  &\Cdots&a_{\rho}^{n}  \\
    a_{\rho u}^{0}&a_{\rho u}^{1}&\Cdots&a_{\rho u}^{n}\\
    a_{\rho v}^{0}&a_{\rho v}^{1}&\Cdots&a_{\rho v}^{n}\\
    a_{\rho w}^{0}&a_{\rho w}^{1}&\Cdots&a_{\rho w}^{n}\\
    a_{\rho E}^{0}&a_{\rho E}^{1}&\Cdots&a_{\rho E}^{n}
  \end{bNiceMatrix}_{\texttt{ConservedVarNum}\times\texttt{BasisFunNum}.}
\end{equation}

\newpage

\bibliographystyle{ieeetr}
\bibliography{references}

\end{document}
