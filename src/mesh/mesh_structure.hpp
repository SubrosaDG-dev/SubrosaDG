/**
 * @file mesh_structure.hpp
 * @brief The mesh structure head file.
 *
 * @author Yufei.Liu, Calm.Liu@outlook.com | Chenyu.Bao, bcynuaa@163.com
 * @date 2022-11-21
 *
 * @version 0.1.0
 * @copyright Copyright (c) 2022 - 2023 by SubrosaDG developers. All rights reserved.
 * SubrosaDG is free software and is distributed under the MIT license.
 */

#ifndef SUBROSA_DG_MESH_STRUCTURE_HPP_
#define SUBROSA_DG_MESH_STRUCTURE_HPP_

// clang-format off

#include <gmsh.h>                  // for clear, open
#include <Eigen/Core>              // for Dynamic, Matrix, Vector
#include <filesystem>              // for path
#include <utility>                 // for pair

#include "basic/data_types.hpp"    // for Isize, Real
#include "mesh/element_types.hpp"  // for ElementType, BasisFunction, kLine, kQuadrangle, kTriangle

// clang-format on

namespace SubrosaDG {

/**
 * @brief The mesh structure for element with index.
 *
 * @tparam Type The element type.
 *
 * @details
 * The `ElementMesh` structure is inherited from `ElementMeshNoIndex` and adds the index information of the elements.
 * Here we use this structure to store the mesh information of the computation element, so the row number of
 * `elements_index_` is `Type.kNodesNumPerElement`.
 */
template <Isize Dimension, ElementType Type>
struct ElementMesh {
  /**
   * @brief The index of the elements tag begin and end.
   *
   * @details
   * `elements_range_.first` is the begin index of the elements tag, and `elements_range_.second` is the end index of
   * the elements tag. To be consistent with Gmsh, the edge indices start from 1. Here we suppose that the elements tag
   * generated by Gmsh is a continuous integer sequence.
   */
  std::pair<Isize, Isize> elements_range_;

  /**
   * @brief The number of elements.
   *
   * @details
   * `elements_num_` is the number of elements. It is equal to `elements_range_.second` subtract `elements_range_.first`
   * plus 1.
   */
  Isize elements_num_;

  /**
   * @brief The nodes coordinates of each element.
   *
   * @details
   * `elements_nodes_` is the nodes coordinates of each element. The size of `elements_nodes_` is
   * `(Type.kDimension * Type.kNodesNumPerElement, elements_num_)`. The first three rows are the coordinates of the
   * first node, and the last three rows are the coordinates of the last node. The column index of `elements_nodes_` is
   * the element index.
   */ // TODO:
  Eigen::Matrix<Real, Dimension * Type.kNodesNumPerElement, Eigen::Dynamic> elements_nodes_;

  /**
   * @brief The index of the nodes of each element.
   *
   * @details
   * `elements_index_` is the index of the element nodes. For calcluated elements(i.e. triangles and quadrilaterals in
   * two dimensions, and tetrahedrons and hexahedrons in three dimensions), the size of `elements_index_` is
   * `(Type.kNodesNumPerElement, elements_num_)`. The first row is the index of the first node, and the last row is the
   * index of the last node. The column index of `elements_index_` is the element index. The matrix can be shown as
   * follows:
   * [e1i1, e2i1, ..., eni1;
   *  e1i2, e2i2, ..., eni2;
   *  ...
   *  e1in, e2in, ..., enin]
   * where en is the element index, and in is the node index.
   */
  Eigen::Matrix<Isize, Type.kNodesNumPerElement, Eigen::Dynamic> elements_index_;

  /**
   * @brief The jacobi value of each element.
   *
   * @details
   * `elements_jacobian_` is the jacobi value of each element. The size of `jacobian_` is `(elements_num_, 1)`. The
   * column index of `elements_jacobian_` is the element index. Since the element in this case are not curved, the
   * determinant of the jacobian matrix is equal to the area of the element. Therefore, it is sufficient to represent
   * the determinant of the jacobian matrix with a single value instead of providing the value of the determinant at
   * each integration point.
   */
  Eigen::Vector<Real, Eigen::Dynamic> elements_jacobian_;
};

/**
 * @brief The mesh structure for Adjacency element with index.
 *
 * @tparam Type The element type.
 *
 * @details
 * The `AdjacencyElementMesh` structure is inherited from `ElementMeshNoIndex` and adds the index information of the
 * elements. Here we use this structure to store the mesh information of the adjacency element, so the row number of
 * `elements_index_` is `Type.kNodesNumPerElement + 2`.
 */
template <Isize Dimension, ElementType Type>
struct AdjacencyElementMesh {
  /**
   * @brief The index of the elements tag begin and end.
   *
   * @details
   * `elements_range_.first` is the begin index of the elements tag, and `elements_range_.second` is the end index of
   * the elements tag. To be consistent with Gmsh, the edge indices start from 1. Here we suppose that the elements tag
   * generated by Gmsh is a continuous integer sequence.
   */
  std::pair<Isize, Isize> internal_elements_range_;

  std::pair<Isize, Isize> boundary_elements_range_;

  /**
   * @brief The number of elements.
   *
   * @details
   * `elements_num_` is the number of elements. It is equal to `elements_range_.second` subtract `elements_range_.first`
   * plus 1.
   */
  std::pair<Isize, Isize> elements_num_;

  /**
   * @brief The nodes coordinates of each element.
   *
   * @details
   * `elements_nodes_` is the nodes coordinates of each element. The size of `elements_nodes_` is
   * `(Type.kDimension * Type.kNodesNumPerElement, elements_num_)`. The first three rows are the coordinates of the
   * first node, and the last three rows are the coordinates of the last node. The column index of `elements_nodes_` is
   * the element index.
   */
  Eigen::Matrix<Real, Dimension * Type.kNodesNumPerElement, Eigen::Dynamic> elements_nodes_;

  /**
   * @brief The index of the nodes and the left and right elements of each element.
   *
   * @details
   * `elements_index_` is the index of the element nodes and the left and right elements. For Adjacency elements(i.e.
   * lines in two dimensions, and triangles and tetrahedrons in three dimensions), the size of `elements_index_` is
   * `(Type.kNodesNumPerElement + 2, elements_num_)`. The first row is the index of the first node, and the last - 2 row
   * is the index of the last node. The last - 1 row is the index of the left element, and the last row is the index of
   * the right element. The column index of `elements_index_` is the element index. Note that the order of left and
   * right elements follows the right-hand rule. This means that the left and right elements of an edge are defined
   * relative to the edge's normal vector, with the normal vector pointing from the left element to the right element.
   * For boundary edges, since the right side is the boundary, the left element represents the internal element, and the
   * right element's position is filled with the value of enum `Boundary` representing the boundary). the matrix can
   * be shown as follows:
   * [e1i1, e2i1, ..., eni1;
   *  e1i2, e2i2, ..., eni2;
   *  ...
   *  e1in, e2in, ..., enin;
   *  e1l,  e2l,  ..., enl;
   *  e1r,  e2r,  ..., enr]
   * where en is the element index, in is the node index, el is the left element index, and er is the right element
   * index.
   */
  Eigen::Matrix<Isize, Type.kNodesNumPerElement + 2, Eigen::Dynamic> elements_index_;

  /**
   * @brief The jacobi value of each element.
   *
   * @details
   * `elements_jacobian_` is the jacobi value of each element. The size of `jacobian_` is `(elements_num_, 1)`. The
   * column index of `elements_jacobian_` is the element index. Since the element in this case are not curved, the
   * determinant of the jacobian matrix is equal to the area of the element. Therefore, it is sufficient to represent
   * the determinant of the jacobian matrix with a single value instead of providing the value of the determinant at
   * each integration point.
   */
  Eigen::Vector<Real, Eigen::Dynamic> elements_jacobian_;
};

template <ElementType Type, Isize PolynomialOrder>
struct ElementGaussianQuadrature {
  /**
   * @brief The number of integral nodes.
   *
   * @details
   * `integral_nodes_num` is the number of integral nodes. The number of integral points is determined by the gauss
   * quadrature accuracy and the type of element.
   */
  inline static Isize integral_nodes_num;

  /**
   * @brief The integral nodes.
   *
   * @details
   * `integral_nodes` is the integral nodes. The size of `integral_nodes` is `(Type.kDimension, integral_nodes_num)`.
   * The row is the coordinate of the integral point, which is the local coordinate of the element.The column index of
   * `integral_nodes` is the integral node index. The matrix can be shown as follows:
   * [x1, x2, ..., xn;
   *  y1, y2, ..., yn;
   *  z1, z2, ..., zn] (if 3D)
   * where n is the integral node index.
   */ // TODO:
  inline static Eigen::Matrix<Real, Type.kDimension, Eigen::Dynamic> integral_nodes;

  /**
   * @brief The weights of each integral point.
   *
   * @details
   * `weights_` is the gauss quadrature weights of each integral point. The size of `weights_` is
   * `(integral_nodes_num_)`. The column index of `weights_` is the integral point index.
   */
  inline static Eigen::Vector<Real, Eigen::Dynamic> weights;
};

/**
 * @brief The integral structure for element, including integral nodes, basis functions and weights.
 *
 * @tparam Type The element type.
 * @tparam PolynomialOrder The polynomial order of the element.
 *
 * @details
 * The `ElementIntegral` structure is inherited from `ElementGaussianQuadrature` structure, and is used to store the
 * integral information of the element. The integral information includes the integral nodes, the basis functions and
 * the weights, which are used to calculate the gauss quadrature integral of the element.
 */
template <ElementType Type, Isize PolynomialOrder>
struct ElementIntegral : ElementGaussianQuadrature<Type, PolynomialOrder> {
  /**
   * @brief The basis functions of each integral point.
   *
   * @details
   * `basis_functions_` is the `polynomial_order_` lagrange basis functions value of each integral point. The size of
   * `basis_functions_` is `(BasisFunction::kNum, integral_nodes_num_)`. The row index is the integral point index,
   * and the column index is the basis function index. That is to say, the basis functions are calculated at the
   * integral points, which are the local coordinates of the element. The matrix can be shown as follows:
   * [f1(p1), f1(p2), ..., f1(pn);
   *  f2(p1), f2(p2), ..., f2(pn);
   *  ...
   *  fn(p1), fn(p2), ..., fn(pn)]
   * where f1, f2, ..., fn are the basis functions, p1, p2, ..., pn are the integral points.
   */
  inline static Eigen::Matrix<Real, BasisFunction<Type, PolynomialOrder>::kNum, Eigen::Dynamic> basis_functions;
};

/**
 * @brief The integral structure for element, including integral nodes, basis functions, grad basis functions and
 * weights.
 *
 * @tparam Type The element type.
 * @tparam PolynomialOrder The polynomial order of the element.
 *
 * @details
 * The `ElementGradIntegral` structure is inherited from `ElementIntegral` structure, and is used to store the integral
 * information of the element. The `ElementGradIntegral` structure adds the gradient of basis functions to the
 * `ElementIntegral` structure. Therefore, the integral information includes the integral nodes, the basis functions,
 * the grad basis functions and the weights, which are used to calculate the gauss quadrature integral of the element.
 */
template <ElementType Type, Isize PolynomialOrder>
struct ElementGradIntegral : ElementIntegral<Type, PolynomialOrder> {
  /**
   * @brief // TODO: Add document.
   */
  inline static Eigen::Matrix<Real, BasisFunction<Type, PolynomialOrder>::kNum,
                              BasisFunction<Type, PolynomialOrder>::kNum>
      local_mass_matrix_inverse;

  /**
   * @brief The gradient of basis functions of each integral point.
   *
   * @details
   * `grad_basis_functions_` is the gradient of basis functions of each integral point. The size of
   * `grad_basis_functions_` is `(BasisFunction::kNum * 3, integral_nodes_num_)`. The row index is the integral point
   * index, which is the same as `basis_functions_`. But this value is the gradient of basis functions, so the row
   * index is multiplied by 3 arranges the gradient of basis functions in the order of x, y, z. The column index is
   * the integral point index. That is to say, the gradient of basis functions are calculated at the integral points,
   * which are the local coordinates of the element. The matrix can be shown as follows:
   * [f1_x(p1), f1_x(p2), ..., f1_x(pn);
   *  f1_y(p1), f1_y(p2), ..., f1_y(pn);
   *  f1_z(p1), f1_z(p2), ..., f1_z(pn); (if 3D)
   *  f2_x(p1), f2_x(p2), ..., f2_x(pn);
   *  f2_y(p1), f2_y(p2), ..., f2_y(pn);
   *  f2_z(p1), f2_z(p2), ..., f2_z(pn); (if 3D)
   *  ...
   *  fn_x(p1), fn_x(p2), ..., fn_x(pn);
   *  fn_y(p1), fn_y(p2), ..., fn_y(pn);
   *  fn_z(p1), fn_z(p2), ..., fn_z(pn)] (if 3D)
   * where f1_x(p1) is the x component of the gradient of the first basis function at the first integral point.
   */ // TODO:
  inline static Eigen::Matrix<Real, Type.kDimension * BasisFunction<Type, PolynomialOrder>::kNum, Eigen::Dynamic>
      grad_basis_functions;
};

/**
 * @brief The element structure, including mesh and integral.
 *
 * @tparam Type The element type.
 * @tparam PolynomialOrder The polynomial order of the element.
 *
 * @details
 * The `Element` structure is inherited from the `ElementMesh` structure and `ElementGradIntegral` structure. This
 * `Element` structure can represent the element that needs to be calculated(i.e. triangles and quadrilaterals in two
 * dimensions, and tetrahedrons and hexahedrons in three dimensions). The calculated element needs to know the
 * `grad_basis_functions_` to calculate the volume integral using gauss quadrature. Therefore, we derive the `Element`
 * structure from the `ElementGradIntegral` structure, not the `ElementIntegral` structure.
 */
template <Isize Dimension, ElementType Type, Isize PolynomialOrder>
struct Element : ElementMesh<Dimension, Type>, ElementGradIntegral<Type, PolynomialOrder> {};

/**
 * @brief The element structure, including mesh and integral.
 *
 * @tparam Type The element type.
 * @tparam PolynomialOrder The polynomial order of the element.
 *
 * @details
 * The `AdjanencyElement` structure is derived from the `ElementMesh` structure and `ElementIntegral` structure. This
 * `AdjanencyElement` structurecan represent the element that does not need to be calculated(i.e. lines in two
 * dimensions, and triangles and quadrilaterals in three dimensions). The calculated element needs to know the
 * `basis_functions_` to calculate the surface integral using gauss quadrature. Therefore, we derive the
 * `AdjanencyElement` structure from the `ElementIntegral` structure, not the `ElementGradIntegral` structure.
 */
template <Isize Dimension, ElementType Type, Isize PolynomialOrder>
struct AdjacencyElement : AdjacencyElementMesh<Dimension, Type>, ElementIntegral<Type, PolynomialOrder> {};

/**
 * @brief The triangle element alias.
 *
 * @tparam PolynomialOrder The polynomial order of the element.
 */
template <Isize Dimension, Isize PolynomialOrder>
using TriangleElement = Element<Dimension, kTriangle, PolynomialOrder>;

/**
 * @brief The quadrangle element alias.
 *
 * @tparam PolynomialOrder The polynomial order of the element.
 */
template <Isize Dimension, Isize PolynomialOrder>
using QuadrangleElement = Element<Dimension, kQuadrangle, PolynomialOrder>;

/**
 * @brief The tetrahedron element alias.
 *
 * @tparam PolynomialOrder The polynomial order of the element.
 */
template <Isize Dimension, Isize PolynomialOrder>
using AdjacencyLineElement = AdjacencyElement<Dimension, kLine, PolynomialOrder>;

/**
 * @brief The mesh structure, including nodes and elements.
 *
 * @tparam Dimension The dimension of the mesh.
 * @tparam PolynomialOrder The polynomial order of the mesh.
 *
 * @details
 * The `Mesh` structure is used to store the mesh information, which includes the nodes.
 */
template <Isize Dimension, Isize PolynomialOrder>
struct Mesh {
  /**
   * @brief The number of nodes in the mesh.
   */
  Isize nodes_num_;

  /**
   * @brief The nodes coordinates of the mesh.
   *
   * @details
   * `nodes_` is the nodes coordinates of the mesh. The size of `nodes_` is `(Dimension, nodes_num_)`. The row index is
   * the coordinate index, which is x, y, z. The column index is the node index.
   */
  Eigen::Matrix<Real, Dimension, Eigen::Dynamic> nodes_;

  std::pair<Isize, Isize> elements_range_;

  Isize elements_num_;

  Eigen::Vector<Isize, Eigen::Dynamic> elements_type_;

  /**
   * @brief The constructor of the `Mesh` structure.
   *
   * @param mesh_file The mesh file path.
   *
   * @details
   * The constructor of the `Mesh` structure is used to open the mesh file when the mesh is initialized.
   */
  inline constexpr Mesh(const std::filesystem::path& mesh_file) { gmsh::open(mesh_file.string()); }

  /**
   * @brief // TODO: Add document.
   */
  inline ~Mesh() { gmsh::clear(); }
};

/**
 * @brief The mesh structure, including nodes and elements.
 *
 * @tparam PolynomialOrder The polynomial order of the mesh.
 *
 * @details
 * The `Mesh2d` structure is used to store the mesh information, which includes the nodes and elements. The dimension
 * of the mesh is two, so the structure is partially specialized from the `Mesh` structure.
 */
template <Isize PolynomialOrder>
struct Mesh2d : Mesh<2, PolynomialOrder> {
  /**
   * @brief The internal line elements of the mesh.
   */
  AdjacencyLineElement<2, PolynomialOrder> line_;

  /**
   * @brief The triangle elements of the mesh.
   */
  TriangleElement<2, PolynomialOrder> triangle_;

  /**
   * @brief The quadrangle elements of the mesh.
   */
  QuadrangleElement<2, PolynomialOrder> quadrangle_;

  /**
   * @brief The constructor of the `Mesh2d` structure, inherited from the `Mesh` structure.
   */
  using Mesh<2, PolynomialOrder>::Mesh;
};

/**
 * @brief The mesh supplemental information structure.
 *
 * @tparam Type The element type.
 *
 * @details
 * The `MeshSupplemental` structure is used to store the supplemental information of the mesh. The supplemental
 * information is used to calculate the boundary conditions or initial conditions.
 */
template <ElementType Type>
struct MeshSupplemental {
  /**
   * @brief The range of the mesh supplemental element.
   *
   * @details
   * The `range_` is the range of the mesh supplemental element tag. The range is get from the `dimension_` in Gmsh.
   */
  std::pair<Isize, Isize> range_;

  /**
   * @brief The number of the mesh supplemental element.
   *
   * @details
   * The `num_` is the number of the mesh supplemental element tag. It is equal to the `range_.second` minus
   * `range_.first` plus one.
   */
  Isize num_;

  /**
   * @brief The index of the mesh supplemental element.
   *
   * @details
   * The `index_` is the index of the mesh supplemental element. The size of `index_` is `(num_)`. The index stores the
   * index of the mesh supplemental element tag(i.e. the `Boundary` enum for the boundary element or the initial region
   * id for the calculation region element).
   */
  Eigen::Vector<Isize, Eigen::Dynamic> index_;
};

}  // namespace SubrosaDG

#endif  // SUBROSA_DG_MESH_STRUCTURE_HPP_
