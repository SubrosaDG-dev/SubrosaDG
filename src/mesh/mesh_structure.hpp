/**
 * @file mesh_structure.hpp
 * @brief The mesh structure head file.
 *
 * @author Yufei.Liu, Calm.Liu@outlook.com | Chenyu.Bao, bcynuaa@163.com
 * @date 2022-11-21
 *
 * @version 0.1.0
 * @copyright Copyright (c) 2022 - 2023 by SubrosaDG developers. All rights reserved.
 * SubrosaDG is free software and is distributed under the MIT license.
 */

#ifndef SUBROSA_DG_MESH_STRUCTURE_HPP_
#define SUBROSA_DG_MESH_STRUCTURE_HPP_

// clang-format off

#include <gmsh.h>                     // for clear, open
#include <Eigen/Core>                 // for Dynamic, Matrix, Vector
#include <filesystem>                 // for path
#include <utility>                    // for pair

#include "basic/concept.hpp"      // IWYU pragma: keep
#include "basic/data_type.hpp"        // for Isize, Real
#include "mesh/elem_type.hpp"         // for ElemInfo, kQuad, kTri, kLine
#include "mesh/cal_basisfun_num.hpp"  // for getBasisFunNum

// clang-format on

namespace SubrosaDG {

/**
 * @brief The mesh structure for element with index.
 *
 * @tparam ElemT The element type.
 *
 * @details
 * The `ElementMesh` structure is inherited from `ElementMeshNoIndex` and adds the index information of the elements.
 * Here we use this structure to store the mesh information of the computation element, so the row number of
 * `elements_index_` is `ElemT.kNodeNum`.
 */
template <Isize Dim, ElemInfo ElemT>
struct ElemMesh {
  /**
   * @brief The index of the elements tag begin and end.
   *
   * @details
   * `elements_range_.first` is the begin index of the elements tag, and `elements_range_.second` is the end index of
   * the elements tag. To be consistent with Gmsh, the edge indices start from 1. Here we suppose that the elements tag
   * generated by Gmsh is a continuous integer sequence.
   */
  std::pair<Isize, Isize> range_;

  /**
   * @brief The number of elements.
   *
   * @details
   * `elements_num_` is the number of elements. It is equal to `elements_range_.second` subtract `elements_range_.first`
   * plus 1.
   */
  Isize num_;

  /**
   * @brief The nodes coordinates of each element.
   *
   * @details
   * `elements_nodes_` is the nodes coordinates of each element. The size of `elements_nodes_` is
   * `(ElemT.kDim * ElemT.kNodeNum, elements_num_)`. The first three rows are the coordinates of the
   * first node, and the last three rows are the coordinates of the last node. The column index of `elements_nodes_` is
   * the element index.
   */ // TODO:
  Eigen::Matrix<Real, Dim * ElemT.kNodeNum, Eigen::Dynamic> node_;

  /**
   * @brief The index of the nodes of each element.
   *
   * @details
   * `elements_index_` is the index of the element nodes. For calcluated elements(i.e. triangles and quadrilaterals in
   * two dimensions, and tetrahedrons and hexahedrons in three dimensions), the size of `elements_index_` is
   * `(ElemT.kNodeNum, elements_num_)`. The first row is the index of the first node, and the last row is the
   * index of the last node. The column index of `elements_index_` is the element index. The matrix can be shown as
   * follows:
   * [e1i1, e2i1, ..., eni1;
   *  e1i2, e2i2, ..., eni2;
   *  ...
   *  e1in, e2in, ..., enin]
   * where en is the element index, and in is the node index.
   */
  Eigen::Matrix<Isize, ElemT.kNodeNum, Eigen::Dynamic> index_;

  /**
   * @brief The jacobi value of each element.
   *
   * @details
   * `elements_jacobian_` is the jacobi value of each element. The size of `jacobian_` is `(elements_num_, 1)`. The
   * column index of `elements_jacobian_` is the element index. Since the element in this case are not curved, the
   * determinant of the jacobian matrix is equal to the area of the element. Therefore, it is sufficient to represent
   * the determinant of the jacobian matrix with a single value instead of providing the value of the determinant at
   * each integration point.
   */
  Eigen::Vector<Real, Eigen::Dynamic> jacobian_;
};

/**
 * @brief The mesh structure for Adjacency element with index.
 *
 * @tparam ElemT The element type.
 *
 * @details
 * The `AdjacencyElementMesh` structure is inherited from `ElementMeshNoIndex` and adds the index information of the
 * elements. Here we use this structure to store the mesh information of the adjacency element, so the row number of
 * `elements_index_` is `ElemT.kNodeNum + 2`.
 */
template <Isize Dim, ElemInfo ElemT>
struct AdjacencyElemMesh {
  /**
   * @brief The index of the elements tag begin and end.
   *
   * @details
   * `elements_range_.first` is the begin index of the elements tag, and `elements_range_.second` is the end index of
   * the elements tag. To be consistent with Gmsh, the edge indices start from 1. Here we suppose that the elements tag
   * generated by Gmsh is a continuous integer sequence.
   */
  std::pair<Isize, Isize> internal_range_;

  std::pair<Isize, Isize> boundary_range_;

  /**
   * @brief The number of elements.
   *
   * @details
   * `elements_num_` is the number of elements. It is equal to `elements_range_.second` subtract `elements_range_.first`
   * plus 1.
   */
  std::pair<Isize, Isize> num_tag_;

  /**
   * @brief The nodes coordinates of each element.
   *
   * @details
   * `elements_nodes_` is the nodes coordinates of each element. The size of `elements_nodes_` is
   * `(ElemT.kDim * ElemT.kNodeNum, elements_num_)`. The first three rows are the coordinates of the
   * first node, and the last three rows are the coordinates of the last node. The column index of `elements_nodes_` is
   * the element index.
   */
  Eigen::Matrix<Real, Dim * ElemT.kNodeNum, Eigen::Dynamic> node_;

  /**
   * @brief The index of the nodes and the left and right elements of each element.
   *
   * @details
   * `elements_index_` is the index of the element nodes and the left and right elements. For Adjacency elements(i.e.
   * lines in two dimensions, and triangles and tetrahedrons in three dimensions), the size of `elements_index_` is
   * `(ElemT.kNodeNum + 2, elements_num_)`. The first row is the index of the first node, and the last - 2 row
   * is the index of the last node. The last - 1 row is the index of the left element, and the last row is the index of
   * the right element. The column index of `elements_index_` is the element index. Note that the order of left and
   * right elements follows the right-hand rule. This means that the left and right elements of an edge are defined
   * relative to the edge's normal vector, with the normal vector pointing from the left element to the right element.
   * For boundary edges, since the right side is the boundary, the left element represents the internal element, and the
   * right element's position is filled with the value of enum `Boundary` representing the boundary). the matrix can
   * be shown as follows:
   * [e1i1, e2i1, ..., eni1;
   *  e1i2, e2i2, ..., eni2;
   *  ...
   *  e1in, e2in, ..., enin;
   *  e1l,  e2l,  ..., enl;
   *  e1r,  e2r,  ..., enr]
   * where en is the element index, in is the node index, el is the left element index, and er is the right element
   * index.
   */
  Eigen::Matrix<Isize, ElemT.kNodeNum + 4, Eigen::Dynamic> index_;

  Eigen::Matrix<Real, Dim, Eigen::Dynamic> norm_vec_;

  /**
   * @brief The jacobi value of each element.
   *
   * @details
   * `elements_jacobian_` is the jacobi value of each element. The size of `jacobian_` is `(elements_num_, 1)`. The
   * column index of `elements_jacobian_` is the element index. Since the element in this case are not curved, the
   * determinant of the jacobian matrix is equal to the area of the element. Therefore, it is sufficient to represent
   * the determinant of the jacobian matrix with a single value instead of providing the value of the determinant at
   * each integration point.
   */
  Eigen::Vector<Real, Eigen::Dynamic> jacobian_;
};

template <ElemInfo ElemT>
struct ElemStandard {
  inline static Eigen::Matrix<Real, ElemT.kNodeNum, ElemT.kDim> local_coord;
};

template <ElemInfo ElemT, Isize PolyOrder>
struct ElemGaussQuad : ElemStandard<ElemT> {
  /**
   * @brief The number of integral nodes.
   *
   * @details
   * `integral_nodes_num` is the number of integral nodes. The number of integral points is determined by the gauss
   * quadrature accuracy and the type of element.
   */
  inline static Isize integral_num;

  /**
   * @brief The integral nodes.
   *
   * @details
   * `integral_nodes` is the integral nodes. The size of `integral_nodes` is `(ElemT.kDim, integral_nodes_num)`.
   * The row is the coordinate of the integral point, which is the local coordinate of the element.The column index of
   * `integral_nodes` is the integral node index. The matrix can be shown as follows:
   * [x1, x2, ..., xn;
   *  y1, y2, ..., yn;
   *  z1, z2, ..., zn] (if 3D)
   * where n is the integral node index.
   */ // TODO:
  // inline static Eigen::Matrix<Real, ElemT.kDim, Eigen::Dynamic> integral_node;

  /**
   * @brief The weights of each integral point.
   *
   * @details
   * `weights_` is the gauss quadrature weights of each integral point. The size of `weights_` is
   * `(integral_nodes_num_)`. The column index of `weights_` is the integral point index.
   */
  inline static Eigen::Vector<Real, Eigen::Dynamic> weight;
};

/**
 * @brief The integral structure for element, including integral nodes, basis functions and weights.
 *
 * @tparam ElemT The element type.
 * @tparam PolyOrder The polynomial order of the element.
 *
 * @details
 * The `ElementIntegral` structure is inherited from `ElementGaussianQuadrature` structure, and is used to store the
 * integral information of the element. The integral information includes the integral nodes, the basis functions and
 * the weights, which are used to calculate the gauss quadrature integral of the element.
 */
template <ElemInfo ElemT, Isize PolyOrder>
struct ElemIntegral : ElemGaussQuad<ElemT, PolyOrder> {
  /**
   * @brief The basis functions of each integral point.
   *
   * @details
   * `basis_functions_` is the `polynomial_order_` lagrange basis functions value of each integral point. The size of
   * `basis_functions_` is `(BasisFun::kNum, integral_nodes_num_)`. The row index is the integral point index,
   * and the column index is the basis function index. That is to say, the basis functions are calculated at the
   * integral points, which are the local coordinates of the element. The matrix can be shown as follows:
   * [f1(p1), f1(p2), ..., f1(pn);
   *  f2(p1), f2(p2), ..., f2(pn);
   *  ...
   *  fn(p1), fn(p2), ..., fn(pn)]
   * where f1, f2, ..., fn are the basis functions, p1, p2, ..., pn are the integral points.
   */
  inline static Eigen::Matrix<Real, getBasisFunNum<ElemT>(PolyOrder), Eigen::Dynamic> basis_funs;

  /**
   * @brief // TODO: Add document.
   */
  inline static Eigen::Matrix<Real, getBasisFunNum<ElemT>(PolyOrder), getBasisFunNum<ElemT>(PolyOrder)>
      local_mass_mat_inv;

  /**
   * @brief The gradient of basis functions of each integral point.
   *
   * @details
   * `grad_basis_functions_` is the gradient of basis functions of each integral point. The size of
   * `grad_basis_functions_` is `(BasisFun::kNum * 3, integral_nodes_num_)`. The row index is the integral point
   * index, which is the same as `basis_functions_`. But this value is the gradient of basis functions, so the row
   * index is multiplied by 3 arranges the gradient of basis functions in the order of x, y, z. The column index is
   * the integral point index. That is to say, the gradient of basis functions are calculated at the integral points,
   * which are the local coordinates of the element. The matrix can be shown as follows:
   * [f1_x(p1), f1_x(p2), ..., f1_x(pn);
   *  f1_y(p1), f1_y(p2), ..., f1_y(pn);
   *  f1_z(p1), f1_z(p2), ..., f1_z(pn); (if 3D)
   *  f2_x(p1), f2_x(p2), ..., f2_x(pn);
   *  f2_y(p1), f2_y(p2), ..., f2_y(pn);
   *  f2_z(p1), f2_z(p2), ..., f2_z(pn); (if 3D)
   *  ...
   *  fn_x(p1), fn_x(p2), ..., fn_x(pn);
   *  fn_y(p1), fn_y(p2), ..., fn_y(pn);
   *  fn_z(p1), fn_z(p2), ..., fn_z(pn)] (if 3D)
   * where f1_x(p1) is the x component of the gradient of the first basis function at the first integral point.
   */ // TODO:
  inline static Eigen::Matrix<Real, getBasisFunNum<ElemT>(PolyOrder), Eigen::Dynamic> grad_basis_funs;
};

/**
 * @brief The integral structure for element, including integral nodes, basis functions, grad basis functions and
 * weights.
 *
 * @tparam ElemT The element type.
 * @tparam PolyOrder The polynomial order of the element.
 *
 * @details
 * The `ElementGradIntegral` structure is inherited from `ElementIntegral` structure, and is used to store the integral
 * information of the element. The `ElementGradIntegral` structure adds the gradient of basis functions to the
 * `ElementIntegral` structure. Therefore, the integral information includes the integral nodes, the basis functions,
 * the grad basis functions and the weights, which are used to calculate the gauss quadrature integral of the element.
 */
template <ElemInfo ElemT, Isize PolyOrder>
struct AdjacencyElemIntegral : ElemGaussQuad<ElemT, PolyOrder> {};

template <ElemInfo ElemT, Isize PolyOrder>
  requires Is1dElem<ElemT>
struct AdjacencyElemIntegral<ElemT, PolyOrder> : ElemGaussQuad<ElemT, PolyOrder> {
  inline static Eigen::Matrix<Real, getBasisFunNum<kTri>(PolyOrder), Eigen::Dynamic> tri_basis_funs;

  inline static Eigen::Matrix<Real, getBasisFunNum<kQuad>(PolyOrder), Eigen::Dynamic> quad_basis_funs;
};

/**
 * @brief The element structure, including mesh and integral.
 *
 * @tparam ElemT The element type.
 * @tparam PolyOrder The polynomial order of the element.
 *
 * @details
 * The `Element` structure is inherited from the `ElementMesh` structure and `ElementGradIntegral` structure. This
 * `Element` structure can represent the element that needs to be calculated(i.e. triangles and quadrilaterals in two
 * dimensions, and tetrahedrons and hexahedrons in three dimensions). The calculated element needs to know the
 * `grad_basis_functions_` to calculate the volume integral using gauss quadrature. Therefore, we derive the `Element`
 * structure from the `ElementGradIntegral` structure, not the `ElementIntegral` structure.
 */
template <Isize Dim, ElemInfo ElemT, Isize PolyOrder>
struct Elem : ElemMesh<Dim, ElemT>, ElemIntegral<ElemT, PolyOrder> {};

/**
 * @brief The element structure, including mesh and integral.
 *
 * @tparam ElemT The element type.
 * @tparam PolyOrder The polynomial order of the element.
 *
 * @details
 * The `AdjanencyElement` structure is derived from the `ElementMesh` structure and `ElementIntegral` structure. This
 * `AdjanencyElement` structurecan represent the element that does not need to be calculated(i.e. lines in two
 * dimensions, and triangles and quadrilaterals in three dimensions). The calculated element needs to know the
 * `basis_functions_` to calculate the surface integral using gauss quadrature. Therefore, we derive the
 * `AdjanencyElement` structure from the `ElementIntegral` structure, not the `ElementGradIntegral` structure.
 */
template <Isize Dim, ElemInfo ElemT, Isize PolyOrder>
struct AdjacencyElem : AdjacencyElemMesh<Dim, ElemT>, AdjacencyElemIntegral<ElemT, PolyOrder> {};

/**
 * @brief The triangle element alias.
 *
 * @tparam PolyOrder The polynomial order of the element.
 */
template <Isize Dim, Isize PolyOrder>
using TriElem = Elem<Dim, kTri, PolyOrder>;

/**
 * @brief The quadrangle element alias.
 *
 * @tparam PolyOrder The polynomial order of the element.
 */
template <Isize Dim, Isize PolyOrder>
using QuadElem = Elem<Dim, kQuad, PolyOrder>;

/**
 * @brief The tetrahedron element alias.
 *
 * @tparam PolyOrder The polynomial order of the element.
 */
template <Isize Dim, Isize PolyOrder>
using AdjacencyLineElem = AdjacencyElem<Dim, kLine, PolyOrder>;

/**
 * @brief The mesh structure, including nodes and elements.
 *
 * @tparam Dim The dimension of the mesh.
 * @tparam PolyOrder The polynomial order of the mesh.
 *
 * @details
 * The `Mesh` structure is used to store the mesh information, which includes the nodes.
 */
template <Isize Dim, Isize PolyOrder>
struct Mesh {
  /**
   * @brief The number of nodes in the mesh.
   */
  Isize node_num_;

  /**
   * @brief The nodes coordinates of the mesh.
   *
   * @details
   * `nodes_` is the nodes coordinates of the mesh. The size of `nodes_` is `(Dim, nodes_num_)`. The row index is
   * the coordinate index, which is x, y, z. The column index is the node index.
   */
  Eigen::Matrix<Real, Dim, Eigen::Dynamic> node_;

  std::pair<Isize, Isize> elem_range_;

  Isize elem_num_;

  Eigen::Vector<Isize, Eigen::Dynamic> elem_type_;

  /**
   * @brief The constructor of the `Mesh` structure.
   *
   * @param mesh_file The mesh file path.
   *
   * @details
   * The constructor of the `Mesh` structure is used to open the mesh file when the mesh is initialized.
   */
  inline constexpr Mesh(const std::filesystem::path& mesh_file) { gmsh::open(mesh_file.string()); }

  /**
   * @brief // TODO: Add document.
   */
  inline ~Mesh() { gmsh::clear(); }
};

/**
 * @brief The mesh structure, including nodes and elements.
 *
 * @tparam PolyOrder The polynomial order of the mesh.
 *
 * @details
 * The `Mesh2d` structure is used to store the mesh information, which includes the nodes and elements. The dimension
 * of the mesh is two, so the structure is partially specialized from the `Mesh` structure.
 */
template <Isize PolyOrder>
struct Mesh2d : Mesh<2, PolyOrder> {
  /**
   * @brief The internal line elements of the mesh.
   */
  AdjacencyLineElem<2, PolyOrder> line_;

  /**
   * @brief The triangle elements of the mesh.
   */
  TriElem<2, PolyOrder> tri_;

  /**
   * @brief The quadrangle elements of the mesh.
   */
  QuadElem<2, PolyOrder> quad_;

  /**
   * @brief The constructor of the `Mesh2d` structure, inherited from the `Mesh` structure.
   */
  using Mesh<2, PolyOrder>::Mesh;
};

/**
 * @brief The mesh supplemental information structure.
 *
 * @tparam ElemT The element type.
 *
 * @details
 * The `MeshSupplemental` structure is used to store the supplemental information of the mesh. The supplemental
 * information is used to calculate the boundary conditions or initial conditions.
 */
template <ElemInfo ElemT>
struct MeshSupplemental {
  /**
   * @brief The range of the mesh supplemental element.
   *
   * @details
   * The `range_` is the range of the mesh supplemental element tag. The range is get from the `dimension_` in Gmsh.
   */
  std::pair<Isize, Isize> range_;

  /**
   * @brief The number of the mesh supplemental element.
   *
   * @details
   * The `num_` is the number of the mesh supplemental element tag. It is equal to the `range_.second` minus
   * `range_.first` plus one.
   */
  Isize num_;

  /**
   * @brief The index of the mesh supplemental element.
   *
   * @details
   * The `index_` is the index of the mesh supplemental element. The size of `index_` is `(num_)`. The index stores the
   * index of the mesh supplemental element tag(i.e. the `Boundary` enum for the boundary element or the initial region
   * id for the calculation region element).
   */
  Eigen::Vector<Isize, Eigen::Dynamic> index_;
};

}  // namespace SubrosaDG

#endif  // SUBROSA_DG_MESH_STRUCTURE_HPP_
