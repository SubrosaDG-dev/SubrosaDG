/**
 * @file mesh_structure.h
 * @brief The mesh structure head file.
 *
 * @author Yufei.Liu, Calm.Liu@outlook.com | Chenyu.Bao, bcynuaa@163.com
 * @date 2022-11-21
 *
 * @version 0.1.0
 * @copyright Copyright (c) 2022 - 2023 by SubrosaDG developers. All rights reserved.
 * SubrosaDG is free software and is distributed under the MIT license.
 */

#ifndef SUBROSA_DG_MESH_STRUCTURE_H_
#define SUBROSA_DG_MESH_STRUCTURE_H_

// clang-format off

#include <Eigen/Core>          // for Dynamic, Matrix, Vector
#include <filesystem>          // for path
#include <utility>             // for pair
#include <string_view>         // for string_view

#include "basic/data_types.h"  // for Isize, Real

// clang-format on

namespace SubrosaDG::Internal {

/**
 * @brief The element information structure, including name, type tag and number of nodes in a single element.
 *
 * @details
 * The `ElementInfo` structure is a virtual structure, which is used to store the information of the element.
 */
struct ElementInfo {
  /**
   * @brief The name of the element.
   *
   * @details
   * `name_` is the name of the element. It is same to the name of the element in Gmsh("Point", "Line", "Triangle",
   * "Quadrangle", "Tetrahedron", "Pyramid", "Prism", "Hexahedron").
   */
  std::string_view name_;

  /**
   * @brief The type tag of the element.
   *
   * @details
   * `element_type_` is the type tag of the element. It is same to the type tag of the element in Gmsh, which is get by
   * `gmsh::model::mesh::getElementType()`. The type tag of the element is defined in the Gmsh manual.
   */
  int element_type_;

  /**
   * @brief The number of nodes per element.
   *
   * @details
   * `nodes_num_per_element_` is the number of nodes per element. It is equal to the number of rows of `elements_nodes_`
   * and `elements_index_` if the element is two-dimensional.
   */
  Isize nodes_num_per_element_;

  ElementInfo(const std::string_view& name, Isize nodes_num_per_element);
};

/**
 * @brief The mesh structure for element, including, elementinfo range, number, nodes and index.
 *
 * @details
 * The `ElementMesh` structure is virtually inherited from `ElementInfo` structure. The `ElementMesh` structure
 * is used to store the mesh information of the elements.
 */
struct ElementMesh : virtual ElementInfo {
  /**
   * @brief The index of the elements tag begin and end.
   *
   * @details
   * `elements_range_.first` is the begin index of the elements tag, and `elements_range_.second` is the end index of
   * the elements tag. To be consistent with Gmsh, the edge indices start from 1. Here we suppose that the elements tag
   * generated by Gmsh is a continuous integer sequence.
   */
  std::pair<Isize, Isize> elements_range_;

  /**
   * @brief The number of elements.
   *
   * @details
   * `elements_num_` is the number of elements. It is equal to `elements_range_.second` subtract `elements_range_.first`
   * plus 1.
   */
  Isize elements_num_;

  /**
   * @brief The nodes coordinates of each element.
   *
   * @details
   * `elements_nodes_` is the nodes coordinates of each element. The size of `elements_nodes_` is
   * `(nodes_num_per_element_ * 3, elements_num_)`. The first three rows are the coordinates of the first node, and the
   * last three rows are the coordinates of the last node. The column index of `elements_nodes_` is the element index.
   */
  Eigen::Matrix<Real, Eigen::Dynamic, Eigen::Dynamic> elements_nodes_;

  /**
   * @brief The index of the element nodes.
   *
   * @details
   * `elements_index_` is the index of the element nodes. For calcluated elements(i.e. triangles and quadrilaterals in
   * two dimensions, and tetrahedrons and hexahedrons in three dimensions), the size of `elements_index_` is
   * `(nodes_num_per_element_, elements_num_)`. The first row is the index of the first node, and the last row is the
   * index of the last node. The column index of `elements_index_` is the element index. For the elements denoting the
   * elements adjancency(i.e. lines in two dimensions, and triangles and tetrahedrons in three dimensions), the size of
   * `elements_index_` is `(nodes_num_per_element_ + 2, elements_num_)`. The first row is the index of the first node,
   * and the last - 2 row is the index of the last node. The last - 1 row is the index of the left element, and the last
   * row is the index of the right element. The column index of `elements_index_` is the element index. Note that the
   * order of left and right elements follows the right-hand rule. This means that the left and right elements of an
   * edge are defined relative to the edge's normal vector, with the normal vector pointing from the left element to the
   * right element. For boundary edges, since the right side is the boundary, the left element represents the interior
   * element, and the right element's position is filled with the value of enum `BoundaryType` representing the boundary
   * type. For calcluated element, the matrix can be shown as follows:
   * [e1i1, e2i1, ..., eni1;
   *  e1i2, e2i2, ..., eni2;
   *  ...
   *  e1in, e2in, ..., enin]
   * where en is the element index, and in is the node index. For element denoting the element adjancency, the matrix
   * can be shown as follows:
   * [e1i1, e2i1, ..., eni1;
   *  e1i2, e2i2, ..., eni2;
   *  ...
   *  e1in, e2in, ..., enin;
   *  e1l,  e2l,  ..., enl;
   *  e1r,  e2r,  ..., enr]
   * where en is the element index, in is the node index, el is the left element index, and er is the right element
   * index.
   */
  Eigen::Matrix<Isize, Eigen::Dynamic, Eigen::Dynamic> elements_index_;

  /**
   * @brief The jacobi value of each element.
   *
   * @details
   * `jacobian_` is the jacobi value of each element. The size of `jacobian_` is `(elements_num_, 1)`. The column index
   * of `jacobian_` is the element index. Since the element in this case are not curved, the determinant of the jacobian
   * matrix is equal to the area of the element. Therefore, it is sufficient to represent the determinant of the
   * jacobian matrix with a single value instead of providing the value of the determinant at each integration point.
   */
  Eigen::Vector<Real, Eigen::Dynamic> elements_jacobian_;

  ElementMesh(const std::string_view& name, Isize nodes_num_per_element);
};

/**
 * @brief The integral structure for element, including elementinfo, integral nodes, basis functions and weights.
 *
 * @details
 * The `ElementIntegral` structure is virtually inherited from `ElementInfo`. The `ElementIntegral` structure is used to
 * calculate the integral of the element, which is gauss quadrature.
 */
struct ElementIntegral : virtual ElementInfo {
  /**
   * @brief The number of integration points.
   *
   * @details
   * `integral_nodes_num_` is the number of integration points. It is used to calculate the integral of the element,
   * which is gauss quadrature. The number of integration points is determined by the gauss quadrature accuracy and the
   * type of element.
   */
  Isize integral_nodes_num_;

  /**
   * @brief The number of basis functions.
   *
   * @details
   * `basis_function_num_` is the number of basis functions. The basis functions are used to calculate the integral of
   * the element, which is gauss quadrature. The number of basis functions is determined by the polynomial order and the
   * type of element.
   */
  Isize basis_function_num_;

  /**
   * @brief The integration points of each element.
   *
   * @details
   * `integral_nodes_` is the integration points of each element. The size of `integral_nodes_` is `(3,
   * integral_nodes_num_)`. The row is the coordinate of the integration point, which is the local coordinate of the
   * element. The column index of `integral_nodes_` is the integration point index.
   */
  Eigen::Matrix<Real, 3, Eigen::Dynamic> integral_nodes_;

  /**
   * @brief The weights of each integration point.
   *
   * @details
   * `weights_` is the gauss quadrature weights of each integration point. The size of `weights_` is
   * `(integral_nodes_num_)`. The column index of `weights_` is the integration point index.
   */
  Eigen::Vector<Real, Eigen::Dynamic> weights_;

  /**
   * @brief The basis functions of each integration point.
   *
   * @details
   * `basis_functions_` is the `polynomial_order_` lagrange basis functions value of each integration point. The size of
   * `basis_functions_` is `(basis_function_num_, integral_nodes_num_)`. The row index is the integration point index,
   * and the column index is the basis function index. That is to say, the basis functions are calculated at the
   * integration points, which are the local coordinates of the element. The matrix can be shown as follows:
   * [f1(p1), f1(p2), ..., f1(pn);
   *  f2(p1), f2(p2), ..., f2(pn);
   *  ...
   *  fn(p1), fn(p2), ..., fn(pn)]
   * where f1, f2, ..., fn are the basis functions, p1, p2, ..., pn are the integration points.
   */
  Eigen::Matrix<Real, Eigen::Dynamic, Eigen::Dynamic> basis_functions_;

  ElementIntegral(const std::string_view& name, Isize nodes_num_per_element);
};

/**
 * @brief The integral structure for element, including gradient of basis functions.
 *
 * @details
 * The `ElementGradIntegral` structure is inherited from the `ElementIntegral` structure. The `ElementGradIntegral`
 * structure adds the gradient of basis functions to the `ElementIntegral` structure. The gradient of basis functions is
 * used to calculate the gradient of the solution at the integration points.
 */
struct ElementGradIntegral : ElementIntegral {
  /**
   * @brief The gradient of basis functions of each integration point.
   *
   * @details
   * `grad_basis_functions_` is the gradient of basis functions of each integration point. The size of
   * `grad_basis_functions_` is `(basis_function_num_ * 3, integral_nodes_num_)`. The row index is the integration point
   * index, which is the same as `basis_functions_`. But this value is the gradient of basis functions, so the row
   * index is multiplied by 3 arranges the gradient of basis functions in the order of x, y, z. The column index is
   * the integration point index. That is to say, the gradient of basis functions are calculated at the integration
   * points, which are the local coordinates of the element. The matrix can be shown as follows:
   * [f1_x(p1), f1_x(p2), ..., f1_x(pn);
   *  f1_y(p1), f1_y(p2), ..., f1_y(pn);
   *  f1_z(p1), f1_z(p2), ..., f1_z(pn);
   *  f2_x(p1), f2_x(p2), ..., f2_x(pn);
   *  f2_y(p1), f2_y(p2), ..., f2_y(pn);
   *  f2_z(p1), f2_z(p2), ..., f2_z(pn);
   *  ...
   *  fn_x(p1), fn_x(p2), ..., fn_x(pn);
   *  fn_y(p1), fn_y(p2), ..., fn_y(pn);
   *  fn_z(p1), fn_z(p2), ..., fn_z(pn)]
   * where f1_x(p1) is the x component of the gradient of the first basis function at the first integration point.
   */
  Eigen::Matrix<Real, Eigen::Dynamic, Eigen::Dynamic> grad_basis_functions_;

  ElementGradIntegral(const std::string_view& name, Isize nodes_num_per_element);
};

/**
 * @brief The element structure, including mesh and integral.
 *
 * @details
 * The `Element` structure is inherited from the `ElementMesh` structure and `ElementGradIntegral` structure. This
 * `Element` structure can represent the element that needs to be calculated(i.e. triangles and quadrilaterals in two
 * dimensions, and tetrahedrons and hexahedrons in three dimensions). The calculated element needs to know the
 * `grad_basis_functions_` to calculate the volume integral using gauss quadrature. Therefore, we derive the `Element`
 * structure from the `ElementGradIntegral` structure, not the `ElementIntegral` structure.
 */
struct Element : ElementMesh, ElementGradIntegral {
  Element(const std::string_view& name, Isize nodes_num_per_element);
};

/**
 * @brief The element structure, including mesh and integral.
 *
 * @details
 * The `AdjanencyElement` structure is derived from the `ElementMesh` structure and `ElementIntegral` structure. This
 * `AdjanencyElement` structurecan represent the element that does not need to be calculated(i.e. lines in two
 * dimensions, and triangles and quadrilaterals in three dimensions). The calculated element needs to know the
 * `basis_functions_` to calculate the surface integral using gauss quadrature. Therefore, we derive the
 * `AdjanencyElement` structure from the `ElementIntegral` structure, not the `ElementGradIntegral` structure.
 */
struct AdjanencyElement : ElementMesh, ElementIntegral {
  AdjanencyElement(const std::string_view& name, Isize nodes_num_per_element);
};

/**
 * @brief The mesh structure, including nodes and elements.
 *
 * @details
 * The `Mesh2d` structure is the mesh structure of two dimensions. It includes the nodes coordinates, elements,
 * polynomial order and gauss integral accuracy. The `Mesh2d` structure is used to calculate the volume integral and
 * surface integral.
 */
struct Mesh2d {
  /**
   * @brief The number of nodes in the mesh.
   */
  Isize nodes_num_;

  /**
   * @brief The nodes coordinates of the mesh.
   *
   * @details
   * `nodes_` is the nodes coordinates of the mesh. The size of `nodes_` is `(3, nodes_num_)`. The row index is the
   * coordinate index, which is x, y, z. The column index is the node index.
   */
  Eigen::Matrix<Real, 3, Eigen::Dynamic> nodes_;

  /**
   * @brief The polynomial order of the mesh.
   *
   * @details
   * `polynomial_order_` is the polynomial order of the mesh, which is the order of discontinuous galerkin method. The
   * polynomial order is used to calculate the basis functions and gauss quadrature points and weights. It is read from
   * the config file.
   */
  Isize polynomial_order_;

  /**
   * @brief The gauss integral accuracy of the mesh.
   *
   * @details
   * `gauss_integral_accuracy_` is the gauss integral accuracy of the mesh. The gauss integral accuracy is used to
   * calculate the gauss quadrature points and weights. It is equal to the double of the polynomial order plus one. The
   * accuracy requirement here is that when computing volume integrals, it should satisfy an accuracy of twice the
   * polynomial order. When computing surface integrals, it should satisfy an accuracy of twice the polynomial order
   * plus one(https://doi.org/10.2514/6.2011-490).
   */
  Isize gauss_integral_accuracy_;

  /**
   * @brief The triangle element of the mesh.
   */
  Element triangle_;

  /**
   * @brief The quadrangle element of the mesh.
   */
  Element quadrangle_;

  /**
   * @brief The interior line element of the mesh.
   */
  AdjanencyElement interior_line_;

  /**
   * @brief The boundary line element of the mesh.
   */
  AdjanencyElement boundary_line_;

  Mesh2d(const std::filesystem::path& mesh_file, Isize polynomial_order);
};

/**
 * @brief The mesh supplemental information structure.
 *
 * @details
 * The `MeshSupplemental` structure is used to store the supplemental information of the mesh. The supplemental
 * information is used to calculate the boundary conditions or initial conditions.
 */
struct MeshSupplemental {
  /**
   * @brief The flag to indicate whether the mesh supplemental element is the adjanency element.
   *
   * @details
   * Here we use the `is_adjanency_element_` to indicate whether the mesh supplemental element is the adjanency
   * element. If the mesh supplemental element is the adjanency element, the `is_adjanency_element_` is `true`.
   * Otherwise, the `is_adjanency_element_` is `false`.
   */
  bool is_adjanency_element_;

  /**
   * @brief The dimension of the mesh supplemental element.
   *
   * @details
   * The `dimension_` is the dimension of the mesh supplemental element information. The dimension is used to get all
   * of the element tags in Gmsh.
   */
  Isize dimension_;

  /**
   * @brief The range of the mesh supplemental element.
   *
   * @details
   * The `range_` is the range of the mesh supplemental element tag. The range is get from the `dimension_` in Gmsh.
   */
  std::pair<Isize, Isize> range_;

  /**
   * @brief The number of the mesh supplemental element.
   *
   * @details
   * The `num_` is the number of the mesh supplemental element tag. It is equal to the `range_.second` minus
   * `range_.first` plus one.
   */
  Isize num_;

  /**
   * @brief The index of the mesh supplemental element.
   *
   * @details
   * The `index_` is the index of the mesh supplemental element. The size of `index_` is `(num_)`. The index stores the
   * index of the mesh supplemental element tag(i.e. the `BoundaryType` for the boundary element or the initial region
   * id for the calculation region element).
   */
  Eigen::Vector<Isize, Eigen::Dynamic> index_;

  MeshSupplemental(bool is_adjanency_element, Isize dimension);
};

}  // namespace SubrosaDG::Internal

#endif  // SUBROSA_DG_MESH_STRUCTURE_H_
